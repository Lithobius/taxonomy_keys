---
title: "BC_fishlist"
author: "Kate Sheridan"
date: "7/24/2022"
output: html_document
---

```{r setup, include=FALSE}
library(taxize)
library(tidyverse)
library(here)

# here filepaths
raw <- here('species_lists', 'BC', 'raw_lists')
processed <- here('species_lists', 'BC', 'processed_lists')
```

When each list is loaded in, it is given a column that indicates it is present in that list.

```{r load-in splists}
# OBIS/GBIF
bigdat_fish <- read_csv(here(raw, 'fish', '20220627_obis-gbif_fish-bc.csv'))[-1] %>%
  mutate(obisgbif = 1)

# Literature
fish_love <- read_csv(here(raw, 'fish', '2021love_fish_gnrdextract.csv')) %>%
  mutate(love2021 = 1) %>%
  janitor::clean_names()

fish_hart <- read_csv(here(raw, 'fish', '2021hart_fish_list_update.csv')) %>%
  mutate(hart = 1)

# Hakai
fish_hakai2020 <- read.csv(here(raw, 'fish',
                                'fishlist_HakaiSurveys_2020.csv')) %>%
  mutate(hakai2020 = 1)

fish_seine <- read_csv(here(raw, 'fish', '20211113_seine_master_fish-list.csv'))[-1] %>%
  mutate(hakaiseine = 1)

fish_samples <- read_csv(here(raw, '20220716_hakai_all_marine_samples-metazoa.csv')) %>%
  filter(phylum == 'Chordata') %>%
  mutate(hakaisample = 1)

```

# Combine

First we'll combine the lists guaranteed to be in BC

```{r one-column}
# hakai samples
fish_samples <- fish_samples %>%
  filter(!(class == 'Ascidiacea')) %>%
  select(species, hakaisample) %>%
  distinct() %>%
  filter(!(species %in% c('Ammodytes sp.', NA)))


fish_list <- fish_hakai2020 %>%
  rename(species = genus_species) %>%
  full_join(fish_hart) %>%
  full_join(fish_seine) %>%
  full_join(fish_samples) %>%
  mutate(across(.cols = everything(), ~ifelse(is.na(.), 0, .)))

write_csv(fish_list, here(processed, '20220724_fish_bc-confirmed.csv'))
```

Both the OBIS/GBIF data and Love 2021 need confirmed before they can be used as reference for filtering eDNA data. While OBIS/GBIF are sightings, they have a lot more species than other lists and should be reviewed with caution for now. Love 2021 has had names extracted without context, so some of these may be "local species looks like foreign species that doesn't live here" and both names get pulled out.

```{r prep others}
# obisgbif
bigdat_fish <- bigdat_fish %>%
  filter(rank == 'species') %>%
  select(species, obisgbif)

# love
fish_love2 <- fish_love %>%
  filter(verif_match_type %in% c('Exact', 'PartialExact')) %>%
  select(verif_matched_canonical, name, love2021) %>%
  distinct() %>%
  #only species epithets
  filter(grepl(' ', verif_matched_canonical)) %>%
  select(!(name)) %>%
  rename(species = verif_matched_canonical) %>%
  distinct()


fish_caution <- bigdat_fish %>%
  full_join(fish_love2) %>%
  full_join(fish_list) %>%
  mutate(caution = ifelse(is.na(hakai2020), 1, 0)) %>%
  mutate(across(.cols = everything(), ~ifelse(is.na(.), 0, .))) %>%
  mutate(verifiedbc = ifelse(caution == 0, 1, 0))

write_csv(fish_caution, here(processed, '20220724_fish_bc-unconfirmed.csv'))

```

# Taxonomy

Extracting fresh taxonomy for everyone, including freshwater-marine status.

```{r worms-function}
library(worrms)

## requires worrms to be loaded
# input is vector of species names
# use wm_records_names to extract 
# this doesn't need the + signs

# right now this breaks if not-found
search_records_worms <- function(spnames) {
  search <- tibble()
  for (i in spnames) {
    print(paste0('searching for ', i))
    record <- wm_records_names(i, marine_only = FALSE)
    message('done')
    search <- append(search, record)
  }
  names(search) <- spnames
  search_output <- map_dfr(.x = search, ~ data.frame(.x), .id = 'query') %>%
    janitor::clean_names() %>%
    select(!(c(url, taxon_rank_id, citation, lsid, modified)))
  return(search_output)
}
```


## Verified only

```{r bc-taxonomy}
# check which ones are in the database
#then replace resolved
fish_search <- fish_list %>%
  select(c(species)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", species)) %>%
  distinct() %>%
  rename(query = species)


# 2: worms
fish_worms <- get_wormsid_(sci_com = fish_search$worms_query, marine_only = FALSE,
                           accepted = FALSE)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
fish_worms2 <- fish_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')


# this cleaning step is relatively temporary until they fix the curl issue
fish_worms2 <- fish_worms2 %>%
  #rename(taxa = scientificname) %>%
  left_join(fish_search, by = c('query' = 'worms_query')) %>%
  select(!(query)) %>%
  rename(taxa = query.y)

# now match species to sciname to remove extra rows
fish_worms2 <- fish_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()


# extract higher and info about freshwater
fish_records <- search_records_worms(fish_worms2$worms_sciname)

# refine results to be useful
fish_records <- fish_records %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

#3: gbif+bold ids
# now we'll search bold
fish_bold <- get_boldid_(sci = fish_search$query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
fish_bold2 <- map_dfr(.x= fish_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(query, bold_id, bold_taxon, rank)))

# GBIF id
fish_gbifid <- get_gbifid_(sci = fish_search$query, rows = 1)

fish_gbifid2 <- map_dfr(.x= fish_gbifid, ~ data.frame(.x), .id = 'query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


fish_tolid <- get_tolid_(fish_search$query)

fish_tolid2 <- map_dfr(.x= fish_tolid, ~ data.frame(.x)) %>%
  filter(rank == 'species') %>%
  select(unique_name, matched_name, ott_id, is_synonym) %>%
  rename(query = matched_name,
         tol_sciname = unique_name)

#4: merge all and find problems
# join all updated fields
fish2 <- fish_search %>%
  left_join(fish_records) %>%
  left_join(fish_bold2) %>%
  left_join(fish_gbifid2) %>%
  left_join(fish_tolid2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  #mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  #relocate(c('found_taxa', 'rank'), .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('is_synonym'), .before = 'valid_authority') %>%
  select(!(c(worms_query, worms_match, original_aphiaid))) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  rename(species = query)


# merge with list
fish_list_taxa <- fish_list %>%
  left_join(fish2) %>%
  relocate(terrestrial_only, freshwater_only, .before = status) %>%
  select(!(c(kingdom, valid_authority, bold_taxon, gbif_sciname, 
             tol_sciname, rank, phylum))) %>%
  relocate(worms_sciname, class, order, family, genus, .before = status)


#write full
write.csv(fish_list_taxa, here(processed, '20220724_fish-bc_confirmed_taxonomy.csv'))
```


```{r}
# check which ones are in the database
#then replace resolved
fish_search2 <- fish_caution %>%
  select(c(species)) %>%
  filter(!(species %in% fish_list$species)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", species)) %>%
  distinct() %>%
  rename(query = species)


# 2: worms
fish_worms3 <- get_wormsid_(sci_com = fish_search2$worms_query, marine_only = FALSE,
                           accepted = FALSE)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
fish_worms2 <- fish_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')


# this cleaning step is relatively temporary until they fix the curl issue
fish_worms2 <- fish_worms2 %>%
  #rename(taxa = scientificname) %>%
  left_join(fish_search2, by = c('query' = 'worms_query')) %>%
  select(!(query)) %>%
  rename(taxa = query.y)

# now match species to sciname to remove extra rows
fish_worms2 <- fish_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()


# extract higher and info about freshwater
fish_records2 <- search_records_worms(fish_worms2$worms_sciname)

# refine results to be useful
fish_records2 <- fish_records2 %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

#3: gbif+bold ids
# now we'll search bold
fish_bold3 <- get_boldid_(sci = fish_search2$query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
fish_bold3 <- map_dfr(.x= fish_bold3, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(query, bold_id, bold_taxon, rank)))

# GBIF id
fish_gbifid3 <- get_gbifid_(sci = fish_search$query, rows = 1)

fish_gbifid3 <- map_dfr(.x= fish_gbifid3, ~ data.frame(.x), .id = 'query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)



fish_tolid3 <- get_tolid_(fish_search2$query)


fish_tolid3 <- map_dfr(.x= fish_tolid3, ~ data.frame(.x)) %>%
  filter(rank == 'species') %>%
  select(unique_name, matched_name, ott_id, is_synonym) %>%
  rename(query = matched_name,
         tol_sciname = unique_name)

#4: merge all and find problems
# join all updated fields
fish3 <- fish_search2 %>%
  left_join(fish_records2) %>%
  left_join(fish_bold3) %>%
  left_join(fish_gbifid3) %>%
  left_join(fish_tolid3) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  #mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  #relocate(c('found_taxa', 'rank'), .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('is_synonym'), .before = 'valid_authority') %>%
  select(!(c(worms_query, worms_match, original_aphiaid))) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  rename(species = query)


# merge with list
fish_list_taxa2 <- fish_caution %>%
  left_join(fish3) %>%
  relocate(terrestrial_only, freshwater_only, .before = status) %>%
  select(!(c(kingdom, valid_authority, bold_taxon, gbif_sciname, 
             tol_sciname, rank, phylum))) %>%
  relocate(worms_sciname, class, order, family, genus, .before = status) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  bind_rows(fish_list_taxa)



#write full
write.csv(fish_list_taxa2, here(processed, '20220724_fish-bc_unconfirmed_taxonomy.csv'))


```




# Problems

```{r find problems}
fish_problems <- fish_caution %>%
  filter(!(species %in% fish_list_taxa2$species))


write.csv(fish_problems, here(raw, 'fish', '20220724_bc_fish-problems.csv'))


```

