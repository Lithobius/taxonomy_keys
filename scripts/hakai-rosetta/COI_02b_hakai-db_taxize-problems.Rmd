---
title: "hakai-db-problem-fix"
author: "Kate Sheridan"
date: '2022-06-27'
output: html_document
---

This script deals with conflicts between what's found in TOL and WoRMS
Generally, this is because the taxa is terrestrial or freshwater. 

```{r setup, include=FALSE}
library(tidyverse)
library(taxize)
library(worrms)
library(here)

# for when i get a modified verison to work
#source(here('scripts',"get_wormsid_mod.R"))

# here filepaths
hakai_blast <- here('species_lists', 'hakai', '2021_blast-db')
rosetta <- here('species_lists', 'hakai', '2022rosetta')
tol_conflict <- here('species_lists', 'hakai', '2022rosetta', 'problems', 'tol_conflict')
```
# load in problems and worms conflicts


```{r worrms-function}
## requires worrms to be loaded
# input is vector of species names
# use wm_records_names to extract 
# this doesn't need the + signs

# right now this breaks if not-found
search_records_worms <- function(spnames) {
  search <- tibble()
  for (i in spnames) {
    print(paste0('searching for ', i))
    record <- wm_records_names(i, marine_only = FALSE)
    message('done')
    search <- append(search, record)
  }
  names(search) <- spnames
  search_output <- map_dfr(.x = search, ~ data.frame(.x), .id = 'query') %>%
    janitor::clean_names() %>%
    select(!(c(url, taxon_rank_id, citation, lsid, modified)))
  return(search_output)
}
```

# annelids

```{r annelid-load}
# remove known problems at load-in
annelid_nf_worms <- read_csv(here(tol_conflict,
                                   '20220718_annelid_worms-tol-conflict.csv'))[-1] %>%
    mutate(tol_sciname = str_replace_all(tol_sciname, ' \\(genus in Holozoa\\)', "")) %>%
  mutate(tol_sciname = str_replace_all(tol_sciname, ' \\(class in Lophotrochozoa\\)', "")) %>%
  mutate(tol_sciname = str_replace_all(tol_sciname, ' \\(species in Opisthokonta\\)', "")) %>%
  mutate(tol_sciname = str_replace_all(tol_sciname, ' \\(subclass in Opisthokonta\\)', ""))
```

```{r annelid-fixes}
# make worms-searchable for temp issue
annelid_search <- annelid_nf_worms %>%
  select(c(tol_sciname)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", tol_sciname))

# first pass to find anything that shouod have been found
annelid_worms_fuzzy <- get_wormsid_(annelid_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
annelid_worms2 <- annelid_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
annelid_worms2 <- annelid_worms2 %>%
  left_join(annelid_search, by = c('query' = 'worms_query')) %>%
  relocate(tol_sciname) %>%
  select(!(query))

# now match species to sciname to remove extra rows
annelid_worms2 <- annelid_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(tol_sciname, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(tol_sciname == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
annelid_records <- search_records_worms(annelid_worms2$tol_sciname)

# generate terrestrial-only and freshwater-only columns
annelid_records <- annelid_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>% 
# rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

# gbif and bold ids
annelid_bold <- get_boldid_(sci = annelid_records$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
annelid_bold2 <- map_dfr(.x= annelid_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))
# GBIF id
annelid_gbifid <- get_gbifid_(sci = annelid_records$taxa_query, rows = 1)

annelid_gbifid2 <- map_dfr(.x= annelid_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)

# join all updated fields
annelid2 <- annelid_nf_worms %>%
  select(taxa_query, ott_id, tol_sciname, is_synonym, flags) %>%
  left_join(annelid_records) %>%
  left_join(annelid_bold2) %>%
  left_join(annelid_gbifid2) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank', 'phylum', 'class', 'order', 'family', 'genus'), .before = 'worms_aphiaid') %>%
  relocate('valid_authority', .before = 'worms_sciname') %>%
  relocate(c('taxa_query', 'status', 'unacceptreason', 'is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_match, original_aphiaid, kingdom)))


# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
annelid_genera <- annelid2 %>%
  filter(rank == 'genus') %>%
  select(!(c(ott_id, tol_sciname, flags, is_synonym, taxa_query))) %>%
  distinct()


# reassess not-found list again
annelid_tol_worms2 <- annelid_nf_worms %>%
  select(taxa_query, ott_id, is_synonym, flags, tol_sciname) %>%
  filter(!(tol_sciname %in% annelid_records$taxa_query)) %>%
  # extract genus names so we can test them
  separate(tol_sciname, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(annelid_genera, by = c('genus_split' = 'genus')) %>%
  filter(!(is.na(found_taxa))) %>%
  select(!(genus_split)) %>%
  mutate(rank = ifelse(tol_sciname == found_taxa, 'genus', 'species')) %>%
  mutate(found_taxa = ifelse(tol_sciname == found_taxa, found_taxa, tol_sciname)) %>%
  relocate(c('ott_id', 'taxa_query'), .before = 'status') %>%
  relocate(c('is_synonym', 'flags'), .before = 'valid_authority') %>%
  relocate('tol_sciname', .before = 'bold_taxon')

# bind generic resolutions
annelid2 <- annelid2 %>%
  bind_rows(annelid_tol_worms2)

# ready to merge
write_csv(annelid2, here(rosetta, 'problems', 'resolved', 
                                  '20220719_annelid_worms_tol-resolved.csv'))
```


```{r annelid generic-search}


#extract list of terrestrial/fresh onlys
annelid_terrfresh <- annelid_nf_worms2 %>%
  filter(terrestrial_only == 1 | freshwater_only == 1)

# filter to who's left
annelid_nf_worms2 <- annelid_nf_worms2 %>%
  filter(!(tol_sciname %in% annelid_terrfresh$tol_sciname))

# get higher taxonomy for these
annelid_ottclassify <- classification(annelid_nf_worms2$tol_sciname, db = 'tol')

annelid_nf_classify <- ottclassifytest %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species)

#select only families to search
annelid_nf_family <- annelid_nf_classify %>%
  select(family) %>%
  distinct()

# which families have worms ids?
annelid_family <- get_wormsid_(annelid_nf_family$family)

annelid_family2 <- annelid_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

annelid_family_records <- search_records_worms(annelid_family2$query)

#generate conflict list at family level
annelid_family_found <- annelid_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  right_join(annelid_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x)

# generate not-found list at family level
annelid_notfound2 <- annelid_nf_classify %>%
  filter(!(family %in% annelid_family2$scientificname)) %>%
  select(query, phylum, class, order, family, genus) %>%
  mutate(across(c(phylum, class, order, family, genus), ~ as.character(.)))
```

```{r annelid-save}


# outstanding conflicts
write_csv(annelid_family_found, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220630_annelid_worms_tol-conflict-family.csv'))

# fresh-terrestrial
write_csv(annelid_terrfresh, here(rosetta, 'problems', 'fresh_terrestrial', 
                                  '20220630_annelid_fresh-terr.csv'))


# still not found in worms
write_csv(annelid_notfound2, here(rosetta, 'problems', 'not_found', 
                                  '20220630_annelid_not_found-tol.csv'))

```




# Arthropoda

```{r}
arthropod_nf_worms <- read_csv(here(tol_conflict,
                                   '20220718_arthropod_worms-tol-conflict.csv'))[-1]
```


```{r}
# make worms-searchable for temp issue
arthropod_search <- arthropod_nf_worms %>%
  select(c(tol_sciname)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", tol_sciname))

# first pass to find anything that shouod have been found
arthropod_worms_fuzzy <- get_wormsid_(arthropod_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
arthropod_worms2 <- arthropod_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
arthropod_worms2 <- arthropod_worms2 %>%
  left_join(arthropod_search, by = c('query' = 'worms_query')) %>%
  relocate(tol_sciname) %>%
  select(!(query))

# now match species to sciname to remove extra rows
arthropod_worms2 <- arthropod_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(tol_sciname, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(tol_sciname == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
arthropod_records <- search_records_worms(arthropod_worms2$tol_sciname)

# generate terrestrial-only and freshwater-only columns
arthropod_records <- arthropod_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))


# add gbif and bold
arthropod_bold <- get_boldid_(sci = arthropod_records$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
arthropod_bold2 <- map_dfr(.x= arthropod_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
arthropod_gbifid <- get_gbifid_(sci = arthropod_records$taxa_query, rows = 1)

arthropod_gbifid2 <- map_dfr(.x= arthropod_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


# join all updated fields
arthropod2 <- arthropod_nf_worms %>%
  select(taxa_query, ott_id, tol_sciname, is_synonym, flags) %>%
  left_join(arthropod_records) %>%
  left_join(arthropod_bold2) %>%
  left_join(arthropod_gbifid2) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank', 'phylum', 'class', 'order', 'family', 'genus'), .before = 'worms_aphiaid') %>%
  relocate('valid_authority', .before = 'worms_sciname') %>%
  relocate(c('taxa_query', 'status', 'unacceptreason', 'is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_match, original_aphiaid, kingdom)))


# ready to merge
write_csv(arthropod_records, here(rosetta, 'problems', 'resolved', 
                                  '20220719_arthropod_worms_tol-resolved.csv'))

```


```{r}

# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
arthropod_genera <- arthropod_records %>%
  filter(rank == 'Genus') %>%
  select(query, valid_name, status, terrestrial_only, freshwater_only, aphia_id) %>%
  distinct()

# reassess not-found list again
arthropod_nf_worms2 <- arthropod_nf_worms %>%
  filter(!(tol_sciname %in% arthropod_records$query)) %>%
  # extract genus names so we can test them
  separate(tol_sciname, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(arthropod_genera, by = c('genus_split' = 'query'))

#extract list of terrestrial/fresh onlys
arthropod_terrfresh <- arthropod_nf_worms2 %>%
  filter(terrestrial_only == 1 | freshwater_only == 1)

# filter to who's left
arthropod_nf_worms2 <- arthropod_nf_worms2 %>%
  filter(!(tol_sciname %in% arthropod_terrfresh$tol_sciname))

# get higher taxonomy for these
arthropod_ottclassify <- classification(arthropod_nf_worms2$tol_sciname, db = 'tol')

arthropod_nf_classify <- arthropod_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
  distinct()


#select only families to search
arthropod_nf_family <- arthropod_nf_classify %>%
  select(family) %>%
  distinct()

# which families have worms ids?
arthropod_family <- get_wormsid_(arthropod_nf_family$family)

arthropod_family2 <- arthropod_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

arthropod_family_records <- search_records_worms(arthropod_family2$query)

#generate conflict list at family level
arthropod_family_found <- arthropod_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  right_join(arthropod_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x)

# generate not-found list at family level
arthropod_notfound2 <- arthropod_nf_classify %>%
  filter(!(family %in% arthropod_family2$scientificname)) %>%
  select(query, phylum, class, order, family, genus) %>%
  mutate(across(c(phylum, class, order, family, genus), ~ as.character(.)))
```

```{r arthropod-save}


# outstanding conflicts
write_csv(arthropod_family_found, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220630_arthropod_worms_tol-conflict-family.csv'))

# fresh-terrestrial
write_csv(arthropod_terrfresh, here(rosetta, 'problems', 'fresh_terrestrial', 
                                  '20220630_arthropod_fresh-terr.csv'))

# still not found in worms
write_csv(arthropod_notfound2, here(rosetta, 'problems', 'not_found', 
                                  '20220630_arthropod_not_found-tol.csv'))
```



# Chordata

```{r}
chordata_nf_worms <- read_csv(here(tol_conflict,
                                   '20220624_chordata_worms-tol-conflict.csv'))[-1]
```

```{r chordata-search}
# make worms-searchable for temp issue
chordata_search <- chordata_nf_worms %>%
  select(c(tol_sciname)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", tol_sciname))

# first pass to find anything that shouod have been found
chordata_worms_fuzzy <- get_wormsid_(chordata_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
chordata_worms2 <- chordata_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
chordata_worms2 <- chordata_worms2 %>%
  left_join(chordata_search, by = c('query' = 'worms_query')) %>%
  relocate(tol_sciname) %>%
  select(!(query))

# now match species to sciname to remove extra rows
chordata_worms2 <- chordata_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(tol_sciname, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(tol_sciname == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
chordata_records <- search_records_worms(chordata_worms2$tol_sciname)

# generate terrestrial-only and freshwater-only columns
chordata_records <- chordata_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct()

# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
chordata_genera <- chordata_records %>%
  filter(rank == 'Genus') %>%
  select(query, valid_name, status, terrestrial_only, freshwater_only, aphia_id) %>%
  distinct()

# reassess not-found list again
chordata_nf_worms2 <- chordata_nf_worms %>%
  filter(!(tol_sciname %in% chordata_records$query)) %>%
  # extract genus names so we can test them
  separate(tol_sciname, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(chordata_genera, by = c('genus_split' = 'query'))

#extract list of terrestrial/fresh onlys
chordata_terrfresh <- chordata_nf_worms2 %>%
  filter(terrestrial_only == 1 | freshwater_only == 1)

# filter to who's left
chordata_nf_worms2 <- chordata_nf_worms2 %>%
  filter(!(tol_sciname %in% chordata_terrfresh$tol_sciname))

# get higher taxonomy for these
chordata_ottclassify <- classification(chordata_nf_worms2$tol_sciname, db = 'tol')

chordata_nf_classify <- chordata_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
  distinct()


#select only families to search
chordata_nf_family <- chordata_nf_classify %>%
  select(family) %>%
  distinct()

# which families have worms ids?
chordata_family <- get_wormsid_(chordata_nf_family$family)

chordata_family2 <- chordata_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

chordata_family_records <- search_records_worms(chordata_family2$query)

#generate conflict list at family level
chordata_family_found <- chordata_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  right_join(chordata_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x)

# generate not-found list at family level
chordata_notfound2 <- chordata_nf_classify %>%
  filter(!(family %in% chordata_family2$scientificname)) %>%
  select(query, phylum, class, order, family, genus) %>%
  mutate(across(c(phylum, class, order, family, genus), ~ as.character(.)))
```




```{r chordata-save}
# ready to merge
write_csv(chordata_records, here(rosetta, 'problems', 'resolved', 
                                  '20220630_chordata_worms_tol-resolved.csv'))

# outstanding conflicts
write_csv(chordata_family_found, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220630_chordata_worms_tol-conflict-family.csv'))

# fresh-terrestrial
write_csv(chordata_terrfresh, here(rosetta, 'problems', 'fresh_terrestrial', 
                                  '20220630_chordata_fresh-terr.csv'))


# still not found in worms
write_csv(chordata_notfound2, here(rosetta, 'problems', 'not_found', 
                                  '20220630_chordata_not_found-tol.csv'))
```


# Molluscs

```{r}
mollusca_nf_worms <- read_csv(here(tol_conflict,
                                   '20220624_mollusca_worms-tol-conflict.csv'))[-1]
```


```{r}
# make worms-searchable for temp issue
mollusca_search <- mollusca_nf_worms %>%
  select(c(tol_sciname)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", tol_sciname))

# first pass to find anything that shouod have been found
mollusca_worms_fuzzy <- get_wormsid_(mollusca_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
mollusca_worms2 <- mollusca_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
mollusca_worms2 <- mollusca_worms2 %>%
  left_join(mollusca_search, by = c('query' = 'worms_query')) %>%
  relocate(tol_sciname) %>%
  select(!(query))

# now match species to sciname to remove extra rows
mollusca_worms2 <- mollusca_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(tol_sciname, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(tol_sciname == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

saveRDS(mollusca_worms2, here('tempmollusca.rds'))



# now use my loop to pull anything found
mollusca_records <- search_records_worms(mollusca_worms2$tol_sciname)

# generate terrestrial-only and freshwater-only columns
mollusca_records <- mollusca_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct()

# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
mollusca_genera <- mollusca_records %>%
  filter(rank == 'Genus') %>%
  select(query, valid_name, status, terrestrial_only, freshwater_only, aphia_id) %>%
  distinct()

# reassess not-found list again
mollusca_nf_worms2 <- mollusca_nf_worms %>%
  filter(!(tol_sciname %in% mollusca_records$query)) %>%
  # extract genus names so we can test them
  separate(tol_sciname, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(mollusca_genera, by = c('genus_split' = 'query'))

#extract list of terrestrial/fresh onlys
mollusca_terrfresh <- mollusca_nf_worms2 %>%
  filter(terrestrial_only == 1 | freshwater_only == 1)

# filter to who's left
mollusca_nf_worms2 <- mollusca_nf_worms2 %>%
  filter(!(tol_sciname %in% mollusca_terrfresh$tol_sciname))

# get higher taxonomy for these
mollusca_ottclassify <- classificatio1n(mollusca_nf_worms2$tol_sciname, db = 'tol')

mollusca_nf_classify <- mollusca_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
  distinct()


#select only families to search
mollusca_nf_family <- mollusca_nf_classify %>%
  select(family) %>%
  distinct()

# which families have worms ids?
mollusca_family <- get_wormsid_(mollusca_nf_family$family)

mollusca_family2 <- mollusca_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

mollusca_family_records <- search_records_worms(mollusca_family2$query)

#generate conflict list at family level
mollusca_family_found <- mollusca_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  right_join(mollusca_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x)

# generate not-found list at family level
mollusca_notfound2 <- mollusca_nf_classify %>%
  filter(!(family %in% mollusca_family2$scientificname)) %>%
  select(query, phylum, class, order, family, genus) %>%
  mutate(across(c(phylum, class, order, family, genus), ~ as.character(.)))
```

```{r}
# ready to merge
write_csv(mollusca_records, here(rosetta, 'problems', 'resolved', 
                                  '20220630_mollusca_worms_tol-resolved.csv'))

# outstanding conflicts
write_csv(mollusca_family_found, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220630_mollusca_worms_tol-conflict-family.csv'))

# fresh-terrestrial
write_csv(mollusca_terrfresh, here(rosetta, 'problems', 'fresh_terrestrial', 
                                  '20220630_mollusca_fresh-terr.csv'))


# still not found in worms
write_csv(mollusca_notfound2, here(rosetta, 'problems', 'not_found', 
                                  '20220630_mollusca_not_found-tol.csv'))
```




# Echinoderms-Nemertea-Platyhelminthes

```{r}
ech_platy_nem_nf_worms <- read_csv(here(tol_conflict,
                                   '20220624_ech_platy_nem_worms-tol-conflict.csv'))[-1]
```



```{r}
# make worms-searchable for temp issue
ech_platy_nem_search <- ech_platy_nem_nf_worms %>%
  select(c(tol_sciname)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", tol_sciname))

# first pass to find anything that shouod have been found
ech_platy_nem_worms_fuzzy <- get_wormsid_(ech_platy_nem_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
ech_platy_nem_worms2 <- ech_platy_nem_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
ech_platy_nem_worms2 <- ech_platy_nem_worms2 %>%
  left_join(ech_platy_nem_search, by = c('query' = 'worms_query')) %>%
  relocate(tol_sciname) %>%
  select(!(query))

# now match species to sciname to remove extra rows
ech_platy_nem_worms2 <- ech_platy_nem_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(tol_sciname, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(tol_sciname == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
ech_platy_nem_records <- search_records_worms(ech_platy_nem_worms2$tol_sciname)

# generate terrestrial-only and freshwater-only columns
ech_platy_nem_records <- ech_platy_nem_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct()

# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
ech_platy_nem_genera <- ech_platy_nem_records %>%
  filter(rank == 'Genus') %>%
  select(query, valid_name, status, terrestrial_only, freshwater_only, aphia_id) %>%
  distinct()

# reassess not-found list again
ech_platy_nem_nf_worms2 <- ech_platy_nem_nf_worms %>%
  filter(!(tol_sciname %in% ech_platy_nem_records$query)) %>%
  # extract genus names so we can test them
  separate(tol_sciname, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(ech_platy_nem_genera, by = c('genus_split' = 'query'))

#extract list of terrestrial/fresh onlys
ech_platy_nem_terrfresh <- ech_platy_nem_nf_worms2 %>%
  filter(terrestrial_only == 1 | freshwater_only == 1)

# filter to who's left
ech_platy_nem_nf_worms2 <- ech_platy_nem_nf_worms2 %>%
  filter(!(tol_sciname %in% ech_platy_nem_terrfresh$tol_sciname))

# get higher taxonomy for these
ech_platy_nem_ottclassify <- classification(ech_platy_nem_nf_worms2$tol_sciname, db = 'tol')

ech_platy_nem_nf_classify <- ech_platy_nem_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
  distinct()


#select only families to search
ech_platy_nem_nf_family <- ech_platy_nem_nf_classify %>%
  select(family) %>%
  distinct()

# which families have worms ids?
ech_platy_nem_family <- get_wormsid_(ech_platy_nem_nf_family$family)

ech_platy_nem_family2 <- ech_platy_nem_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

ech_platy_nem_family_records <- search_records_worms(ech_platy_nem_family2$query)

#generate conflict list at family level
ech_platy_nem_family_found <- ech_platy_nem_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  right_join(ech_platy_nem_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x)

# generate not-found list at family level
ech_platy_nem_notfound2 <- ech_platy_nem_nf_classify %>%
  filter(!(family %in% ech_platy_nem_family2$scientificname)) %>%
  select(query, phylum, class, order, family, genus) %>%
  mutate(across(c(phylum, class, order, family, genus), ~ as.character(.)))
```


```{r}
# ready to merge
write_csv(ech_platy_nem_records, here(rosetta, 'problems', 'resolved', 
                                  '20220630_ech_platy_nem_worms_tol-resolved.csv'))

# outstanding conflicts
write_csv(ech_platy_nem_family_found, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220630_ech_platy_nem_worms_tol-conflict-family.csv'))

# fresh-terrestrial
write_csv(ech_platy_nem_terrfresh, here(rosetta, 'problems', 'fresh_terrestrial', 
                                  '20220630_ech_platy_nem_fresh-terr.csv'))


# still not found in worms
write_csv(ech_platy_nem_notfound2, here(rosetta, 'problems', 'not_found', 
                                  '20220630_ech_platy_nem_not_found-tol.csv'))
```


# Small phyla

```{r}
smallphyla_nf_worms <- read_csv(here(tol_conflict,
                                   '20220624_small_phyla_worms-tol-conflict.csv'))[-1]
```



```{r}
# make worms-searchable for temp issue
smallphyla_search <- smallphyla_nf_worms %>%
  select(c(tol_sciname)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", tol_sciname))

# first pass to find anything that shouod have been found
smallphyla_worms_fuzzy <- get_wormsid_(smallphyla_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
smallphyla_worms2 <- smallphyla_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
smallphyla_worms2 <- smallphyla_worms2 %>%
  left_join(smallphyla_search, by = c('query' = 'worms_query')) %>%
  relocate(tol_sciname) %>%
  select(!(query))

# now match species to sciname to remove extra rows
smallphyla_worms2 <- smallphyla_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(tol_sciname, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(tol_sciname == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
smallphyla_records <- search_records_worms(smallphyla_worms2$tol_sciname)

# generate terrestrial-only and freshwater-only columns
smallphyla_records <- smallphyla_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct()

# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
smallphyla_genera <- smallphyla_records %>%
  filter(rank == 'Genus') %>%
  select(query, valid_name, status, terrestrial_only, freshwater_only, aphia_id) %>%
  distinct()

# reassess not-found list again
smallphyla_nf_worms2 <- smallphyla_nf_worms %>%
  filter(!(tol_sciname %in% smallphyla_records$query)) %>%
  # extract genus names so we can test them
  separate(tol_sciname, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(smallphyla_genera, by = c('genus_split' = 'query'))

#extract list of terrestrial/fresh onlys
smallphyla_terrfresh <- smallphyla_nf_worms2 %>%
  filter(terrestrial_only == 1 | freshwater_only == 1)

# filter to who's left
smallphyla_nf_worms2 <- smallphyla_nf_worms2 %>%
  filter(!(tol_sciname %in% smallphyla_terrfresh$tol_sciname))

# get higher taxonomy for these
smallphyla_ottclassify <- classification(smallphyla_nf_worms2$tol_sciname, db = 'tol')

smallphyla_nf_classify <- smallphyla_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species)

#select only families to search
smallphyla_nf_family <- smallphyla_nf_classify %>%
  select(family) %>%
  filter(!(is.na(family))) %>%
  distinct()

# which families have worms ids?
smallphyla_family <- get_wormsid_(smallphyla_nf_family$family)

smallphyla_family2 <- smallphyla_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

smallphyla_family_records <- search_records_worms(smallphyla_family2$query)

#generate conflict list at family level
smallphyla_family_found <- smallphyla_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  right_join(smallphyla_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x)

# generate not-found list at family level
smallphyla_notfound2 <- smallphyla_nf_classify %>%
  filter(!(family %in% smallphyla_family2$scientificname)) %>%
  select(query, phylum, class, order, family, genus) %>%
  mutate(across(c(phylum, class, order, family, genus), ~ as.character(.)))
```



```{r small-phyla-save}
# ready to merge
write_csv(smallphyla_records, here(rosetta, 'problems', 'resolved', 
                                  '20220630_smallphyla_worms_tol-resolved.csv'))

# outstanding conflicts
write_csv(smallphyla_family_found, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220630_smallphyla_worms_tol-conflict-family.csv'))

# fresh-terrestrial
write_csv(smallphyla_terrfresh, here(rosetta, 'problems', 'fresh_terrestrial', 
                                  '20220630_smallphyla_fresh-terr.csv'))


# still not found in worms
write_csv(smallphyla_notfound2, here(rosetta, 'problems', 'not_found', 
                                  '20220630_smallphyla_not_found-tol.csv'))
```


# scratch work


this is what I wrote for the annelid chunk before rewriting the taxize call
keep for now until i know I don't need it
```{r original-annelid}
annelid_search3 <- annelid_search[10:15,]

annelid_search2 <- annelid_worms2[4:7,] %>%
  select(tol_sciname) %>%
  filter(!(is.na(tol_sciname))) %>%
  distinct() %>%
  mutate(worms_query = gsub(" ", "+", tol_sciname))

# this worms search needs to be very broad
annelid_worms_fuzzy <- get_wormsid_(sci_com = annelid_search3$worms_query, 
                                    fuzzy = TRUE, marine_only = FALSE,
                                    accepted = FALSE)

# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
annelid_worms2 <- annelid_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
annelid_worms2 <- annelid_worms2 %>%
  left_join(annelid_search, by = c('query' = 'worms_query')) %>%
  relocate(tol_sciname) %>%
  select(!(query))

# now match species to sciname to remove extra rows
annelid_worms2 <- annelid_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(tol_sciname, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(tol_sciname == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# in some instances the scientific name wasn't found
# even though it was accepted? set aside to classify
annelid_accepted <- annelid_worms2 %>%
  filter(status %in% c('accepted', 'alternate representation'))


annelid_issue <- annelid_worms2 %>%
  filter(!(status %in% c('accepted', 'alternate representation')))

table(annelid_issue$status)




annelid_classify <- classification(annelid_alternate$worms_aphiaid, db = 'worms')
# make and rotate dataframe 
annelid_classify2 <- map_dfr(.x = annelid_classify, ~ data.frame(.x), .id = 'worms_aphiaid') %>%
  pivot_wider(id_cols = worms_aphiaid, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'wormsid_')) %>%
  mutate(worms_aphiaid = as.numeric(worms_aphiaid)) %>%
  janitor::clean_names()

annelid_worms3 <- annelid_worms2 %>%
  left_join(annelid_classify2) %>%
  filter(kingdom == 'Animalia') %>%
  janitor::remove_empty() %>%
  #select only desired taxonomic levels and their IDs
  ## note subgenus was empty here but it probably shouldn't be
  select(c(tol_sciname, worms_aphiaid, worms_sciname,
           phylum, class, subclass, order, family, genus, #subgenus, 
           species,
           wormsid_phylum, wormsid_class, wormsid_subclass, wormsid_order,
           wormsid_family, wormsid_genus, #wormsid_subgenus, 
           wormsid_species,
           authority)) %>%
  

```

