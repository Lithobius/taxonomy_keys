---
title: "hakai-db-problem-fix"
author: "Kate Sheridan"
date: '2022-06-27'
output: html_document
---

This script deals with conflicts between what's found in TOL and WoRMS
Generally, this is because the taxa is terrestrial or freshwater. 

```{r setup, include=FALSE}
library(tidyverse)
library(taxize)
library(worrms)
library(here)

# for when i get a modified verison to work
#source(here('scripts',"get_wormsid_mod.R"))

# here filepaths
hakai_blast <- here('species_lists', 'hakai', '2021_blast-db')
rosetta <- here('species_lists', 'hakai', '2022rosetta')
tol_conflict <- here('species_lists', 'hakai', '2022rosetta', 'problems', 'tol_conflict')
```
# load in problems and worms conflicts


```{r worrms-function}
## requires worrms to be loaded
# input is vector of species names
# use wm_records_names to extract 
# this doesn't need the + signs

# right now this breaks if not-found
search_records_worms <- function(spnames) {
  search <- tibble()
  for (i in spnames) {
    print(paste0('searching for ', i))
    record <- wm_records_names(i, marine_only = FALSE)
    message('done')
    search <- append(search, record)
  }
  names(search) <- spnames
  search_output <- map_dfr(.x = search, ~ data.frame(.x), .id = 'query') %>%
    janitor::clean_names() %>%
    select(!(c(url, taxon_rank_id, citation, lsid, modified)))
  return(search_output)
}
```

# annelids

```{r annelid-load}
# remove known problems at load-in
annelid_nf_worms <- read_csv(here(tol_conflict,
                                   '20220718_annelid_worms-tol-conflict.csv'))[-1] %>%
  #clean found_taxa column
  mutate(found_taxa = str_remove_all(found_taxa, " \\(.*\\)")) %>%
  mutate(found_taxa = trimws(found_taxa))
```

```{r annelid-fixes}
# make worms-searchable for temp issue
annelid_search <- annelid_nf_worms %>%
  select(c(found_taxa)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", found_taxa))

# first pass to find anything that shouod have been found
annelid_worms_fuzzy <- get_wormsid_(annelid_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
annelid_worms2 <- annelid_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
annelid_worms2 <- annelid_worms2 %>%
  left_join(annelid_search, by = c('query' = 'worms_query')) %>%
  relocate(found_taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
annelid_worms2 <- annelid_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(found_taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(found_taxa == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
annelid_records <- search_records_worms(annelid_worms2$found_taxa)

# generate terrestrial-only and freshwater-only columns
annelid_records <- annelid_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>% 
# rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

# gbif and bold ids
annelid_bold <- get_boldid_(sci = annelid_records$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
annelid_bold2 <- map_dfr(.x= annelid_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))
# GBIF id
annelid_gbifid <- get_gbifid_(sci = annelid_records$taxa_query, rows = 1)

annelid_gbifid2 <- map_dfr(.x= annelid_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)

# join all updated fields
annelid2 <- annelid_nf_worms %>%
  select(taxa_query, ott_id, tol_sciname, is_synonym, flags) %>%
  left_join(annelid_records) %>%
  left_join(annelid_bold2) %>%
  left_join(annelid_gbifid2) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank', 'phylum', 'class', 'order', 'family', 'genus'), .before = 'worms_aphiaid') %>%
  relocate('valid_authority', .before = 'worms_sciname') %>%
  relocate(c('taxa_query', 'status', 'unacceptreason', 'is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_match, original_aphiaid, kingdom)))


# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
annelid_freshterr_gen <- annelid2 %>%
  filter(rank %in% c('species', 'genus')) %>%
  select(class, order, phylum, family, genus, worms_aphiaid, freshwater_only, terrestrial_only) %>%
  #select(!(c(ott_id, tol_sciname, flags, is_synonym, taxa_query, found_taxa))) %>%
  filter(freshwater_only == 1 | terrestrial_only == 1) %>%
  distinct(genus, .keep_all = TRUE)


# reassess not-found list again
annelid_genera_fix <- annelid_nf_worms %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname) %>%
  filter(!(found_taxa %in% annelid_records$taxa_query)) %>%
  # extract genus names so we can test them
  separate(found_taxa, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(annelid_freshterr_gen, by = c('genus_split' = 'genus')) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  rename(genus = genus_split) %>%
  mutate(rank = ifelse(str_detect(found_taxa, " ") == FALSE, 'genus', 'species'))

# bind generic resolutions
annelid2 <- annelid2 %>%
  bind_rows(annelid_genera_fix)

# family-level search
## typically this will be terrestrial or freshwater-only families
annelid_nf_families <- annelid_nf_worms %>%
  filter(!(taxa_query %in% annelid2$taxa_query)) %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname, family)


annelid_family_fix <- annelid2 %>%
  filter(rank == 'family') %>%
  select(!(c(ott_id, tol_sciname, flags, is_synonym, taxa_query, found_taxa))) %>%
  distinct() %>%
  right_join(annelid_nf_families) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  # any  marine-only or possibly marine taxa should be put on the actual-problems list
  filter(freshwater_only == 1 | terrestrial_only == 1) %>%
  # these are all specific level IDs as generic level was resolved earlier
  ## rank should reflect this
  mutate(rank = recode(rank, family = 'species'))

# bind family resolutions
annelid2 <- annelid2 %>%
  bind_rows(annelid_family_fix)

# ready to merge
write_csv(annelid2, here(rosetta, 'problems', 'resolved', 
                                  '20220719_annelid_worms_tol-resolved.csv'))
```

## outstanding problems
```{r annelid outstanding-problems}
# get a family level ID to who's left so that 
# problems can be resolved at a higher taxonomy
## since now its manual solving time!

# filter to who's left
annelid_nf_worms2 <- annelid_nf_worms %>%
  filter(!(taxa_query %in% annelid2$taxa_query)) %>%
  select(taxa_query, found_taxa, ott_id, is_synonym, flags, tol_sciname, family)


# get higher taxonomy for these
annelid_ottclassify <- classification(annelid_nf_worms2$found_taxa, db = 'tol')

annelid_nf_classify <- annelid_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species)

#select only families to search
annelid_nf_family <- annelid_nf_classify %>%
  select(family) %>%
  distinct() %>%
  mutate(family = as.character(family)) %>%
  filter(!(family == 'NULL')) %>%
  # replace any odd strings
  mutate(family = str_replace(family, 'c\\(\\"Siboglinidae\\", \\"Siboglinidae\\", \\"Siboglinidae\\"\\)', 'Siboglinidae'))

# which families have worms ids?
annelid_family <- get_wormsid_(annelid_nf_family$family)

annelid_family2 <- annelid_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

annelid_family_records <- search_records_worms(annelid_family2$query)

#generate conflict list at family level
annelid_problems2 <- annelid_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  full_join(annelid_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x) %>%
  mutate(across(c(ottid_species, phylum, class, order, family, genus), ~ as.character(.)))

# outstanding conflicts
write_csv(annelid_problems2, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220720_annelid_worms_tol-conflict-family.csv'))
```


# Arthropoda

```{r}
arthropod_nf_worms <- read_csv(here(tol_conflict,
                                   '20220718_arthropod_worms-tol-conflict.csv'))[-1] %>%
  #clean found_taxa column
  mutate(found_taxa = str_remove_all(found_taxa, " \\(.*\\)")) %>%
  mutate(found_taxa = trimws(found_taxa))
```

```{r arthropod fix}
# make worms-searchable for temp issue
arthropod_search <- arthropod_nf_worms %>%
  select(c(found_taxa)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", found_taxa))

# first pass to find anything that shouod have been found
arthropod_worms_fuzzy <- get_wormsid_(arthropod_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
arthropod_worms2 <- arthropod_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
arthropod_worms2 <- arthropod_worms2 %>%
  left_join(arthropod_search, by = c('query' = 'worms_query')) %>%
  relocate(found_taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
arthropod_worms2 <- arthropod_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(found_taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(found_taxa == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
arthropod_records <- search_records_worms(arthropod_worms2$found_taxa)

# generate terrestrial-only and freshwater-only columns
arthropod_records <- arthropod_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))


# add gbif and bold
arthropod_bold <- get_boldid_(sci = arthropod_records$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
arthropod_bold2 <- map_dfr(.x= arthropod_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
arthropod_gbifid <- get_gbifid_(sci = arthropod_records$taxa_query, rows = 1)

arthropod_gbifid2 <- map_dfr(.x= arthropod_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


# join all updated fields
arthropod2 <- arthropod_nf_worms %>%
  select(taxa_query, found_taxa, ott_id, tol_sciname, is_synonym, flags) %>%
  left_join(arthropod_records) %>%
  left_join(arthropod_bold2) %>%
  left_join(arthropod_gbifid2) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank', 'phylum', 'class', 'order', 'family', 'genus'), .before = 'worms_aphiaid') %>%
  relocate('valid_authority', .before = 'worms_sciname') %>%
  relocate(c('taxa_query', 'status', 'unacceptreason', 'is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_match, original_aphiaid, kingdom)))

# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
arthropod_freshterr_gen <- arthropod2 %>%
  filter(rank %in% c('species', 'genus')) %>%
  select(class, order, phylum, family, genus, worms_aphiaid, freshwater_only, terrestrial_only) %>%
  filter(freshwater_only == 1 | terrestrial_only == 1) %>%
  distinct(genus, .keep_all = TRUE)


# reassess not-found list again
arthropod_genera_fix <- arthropod_nf_worms %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, found_taxa) %>%
  filter(!(found_taxa %in% arthropod_records$taxa_query)) %>%
  # extract genus names so we can test them
  separate(found_taxa, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(arthropod_freshterr_gen, by = c('genus_split' = 'genus')) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  rename(genus = genus_split) %>%
  mutate(rank = ifelse(str_detect(found_taxa, " ") == FALSE, 'genus', 'species'))

# bind generic resolutions
arthropod2 <- arthropod2 %>%
  bind_rows(arthropod_genera_fix)

# all NA's again so skipping this step
arthropod_nf_families <- arthropod_nf_worms %>%
  filter(!(taxa_query %in% arthropod2$taxa_query)) %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname, family)

# ready to merge
write_csv(arthropod2, here(rosetta, 'problems', 'resolved', 
                                  '20220719_arthropod_worms_tol-resolved.csv'))
```

```{r arthropod-outstanding}
# filter to who's left
arthropod_nf_worms2 <- arthropod_nf_worms %>%
  filter(!(taxa_query %in% arthropod2$taxa_query)) %>%
  select(taxa_query, found_taxa, ott_id, is_synonym, flags, tol_sciname, family)

# get higher taxonomy for these
arthropod_ottclassify <- classification(arthropod_nf_worms2$taxa_query, db = 'tol')

arthropod_nf_classify <- arthropod_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
  distinct()


#select only families to search
arthropod_nf_family <- arthropod_nf_classify %>%
  select(family) %>%
  distinct()

#select only families to search
arthropod_nf_family <- arthropod_nf_classify %>%
  select(family) %>%
  filter(!(is.na(family))) %>%
  filter(!(family == 'NULL')) %>%
  distinct()

# which families have worms ids?
arthropod_family <- get_wormsid_(arthropod_nf_family$family)

arthropod_family2 <- arthropod_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

arthropod_family_records <- search_records_worms(arthropod_family2$query)

#generate conflict list at family level
arthropod_problem2 <- arthropod_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  right_join(arthropod_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x) %>%
  rename(taxa_query = query) %>%
    mutate(across(c(ottid_species, phylum, class, order, family, genus), ~ as.character(.))) %>%
  distinct(taxa_query, .keep_all = TRUE)


# outstanding conflicts
write_csv(arthropod_problem2, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220720_arthropod_worms_tol-conflict-family.csv'))
```


# Chordata

```{r}
chordata_nf_worms <- read_csv(here(tol_conflict,
                                   '20220718_chordata_worms-tol-conflict.csv'))[-1] %>%
  #clean found_taxa column
  mutate(found_taxa = str_remove_all(found_taxa, " \\(.*\\)")) %>%
  mutate(found_taxa = trimws(found_taxa))
```

```{r chordata-search}
# make worms-searchable for temp issue
chordata_search <- chordata_nf_worms %>%
  select(c(taxa_query)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", taxa_query))

# first pass to find anything that shouod have been found
chordata_worms_fuzzy <- get_wormsid_(chordata_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
chordata_worms2 <- chordata_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
chordata_worms2 <- chordata_worms2 %>%
  left_join(chordata_search, by = c('query' = 'worms_query')) %>%
  relocate(taxa_query) %>%
  select(!(query))

# now match species to sciname to remove extra rows
chordata_worms2 <- chordata_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa_query, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa_query == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
chordata_records <- search_records_worms(chordata_worms2$taxa_query)

# generate terrestrial-only and freshwater-only columns
chordata_records <- chordata_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  mutate(rank = tolower(rank)) %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) 


# gbif and bold ids
chordata_bold <- get_boldid_(sci = chordata_records$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
chordata_bold2 <- map_dfr(.x= chordata_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
chordata_gbifid <- get_gbifid_(sci = chordata_records$taxa_query, rows = 1)

chordata_gbifid2 <- map_dfr(.x= chordata_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


# join all updated fields
chordata2 <- chordata_nf_worms %>%
  select(taxa_query, ott_id, tol_sciname, is_synonym, flags) %>%
  left_join(chordata_records) %>%
  left_join(chordata_bold2) %>%
  left_join(chordata_gbifid2) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank', 'phylum', 'class', 'order', 'family', 'genus'), .before = 'worms_aphiaid') %>%
  relocate('valid_authority', .before = 'worms_sciname') %>%
  relocate(c('taxa_query', 'status', 'unacceptreason', 'is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_match, original_aphiaid, kingdom)))


# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
chordata_freshterr_gen <- chordata2 %>%
  filter(rank %in% c('species', 'genus')) %>%
  select(class, order, phylum, family, genus, worms_aphiaid, freshwater_only, terrestrial_only) %>%
  filter(freshwater_only == 1 | terrestrial_only == 1) %>%
  distinct(genus, .keep_all = TRUE)

# no fixed genera
# reassess not-found list again
chordata_genera_fix <- chordata_nf_worms %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname) %>%
  filter(!(found_taxa %in% chordata_records$taxa_query)) %>%
  # extract genus names so we can test them
  separate(found_taxa, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(chordata_freshterr_gen, by = c('genus_split' = 'genus')) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  rename(genus = genus_split) %>%
  mutate(rank = ifelse(str_detect(found_taxa, " ") == FALSE, 'genus', 'species'))

# bind generic resolutions
#chordata2 <- chordata2 %>%
#  bind_rows(chordata_genera_fix)

# family-level search
## typically this will be terrestrial or freshwater-only families
chordata_nf_families <- chordata_nf_worms %>%
  filter(!(taxa_query %in% chordata2$taxa_query)) %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname, family)

# all families NA


# ready to merge
write_csv(chordata2, here(rosetta, 'problems', 'resolved', 
                                  '20220719_chordata_worms_tol-resolved.csv'))
```
## Outstanding problems
```{r chordata-outstanding}
# filter to who's leftt
chordata_nf_worms2 <- chordata_nf_worms %>%
  filter(!(taxa_query %in% chordata2$taxa_query)) %>%
  select(taxa_query, found_taxa, ott_id, is_synonym, flags, tol_sciname, family)

# get higher taxonomy for these
chordata_ottclassify <- classification(chordata_nf_worms2$found_taxa, db = 'tol')

chordata_nf_classify <- chordata_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
  distinct()



#select only families to search
chordata_nf_family <- chordata_nf_classify %>%
  select(family) %>%
  distinct() %>%
  filter(!(is.na(family))) %>%
  filter(!(family == 'NULL')) %>%
  distinct() #%>%

# which families have worms ids?
chordata_family <- get_wormsid_(chordata_nf_family$family)

chordata_family2 <- chordata_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

chordata_family_records <- search_records_worms(chordata_family2$query)

#generate conflict list at family level
chordata_problems2 <- chordata_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  full_join(chordata_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x) %>%
  rename(taxa_query = query) %>%
  mutate(across(c(ottid_species, phylum, class, order, family, genus), ~ as.character(.))) %>%
  distinct(taxa_query, .keep_all = TRUE)

# outstanding conflicts
write_csv(chordata_problems2, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220720_chordata_worms_tol-conflict-family.csv'))
```



# Molluscs

```{r mollusc-loadin}
mollusca_nf_worms <- read_csv(here(tol_conflict,
                                   '20220718_mollusca_worms-tol-conflict.csv'))[-1] %>%
  #clean found_taxa column
  mutate(found_taxa = str_remove_all(found_taxa, " \\(.*\\)")) %>%
  mutate(found_taxa = trimws(found_taxa))
```

```{r mollusc-fix}
# make worms-searchable for temp issue
mollusca_search <- mollusca_nf_worms %>%
  select(c(found_taxa)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", found_taxa))

# first pass to find anything that shouod have been found
mollusca_worms_fuzzy <- get_wormsid_(mollusca_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
mollusca_worms2 <- mollusca_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
mollusca_worms2 <- mollusca_worms2 %>%
  left_join(mollusca_search, by = c('query' = 'worms_query')) %>%
  relocate(found_taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
mollusca_worms2 <- mollusca_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(found_taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(found_taxa == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

#saveRDS(mollusca_worms2, here('tempmollusca.rds'))

# now use my loop to pull anything found
mollusca_records <- search_records_worms(mollusca_worms2$found_taxa)

# generate terrestrial-only and freshwater-only columns
mollusca_records <- mollusca_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct()%>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

# gbif and bold ids
mollusca_bold <- get_boldid_(sci = mollusca_records$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
mollusca_bold2 <- map_dfr(.x= mollusca_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
mollusca_gbifid <- get_gbifid_(sci = mollusca_records$taxa_query, rows = 1)

mollusca_gbifid2 <- map_dfr(.x= mollusca_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


# join all updated fields
mollusca2 <- mollusca_nf_worms %>%
  select(taxa_query, ott_id, tol_sciname, is_synonym, flags) %>%
  left_join(mollusca_records) %>%
  left_join(mollusca_bold2) %>%
  left_join(mollusca_gbifid2) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank', 'phylum', 'class', 'order', 'family', 'genus'), .before = 'worms_aphiaid') %>%
  relocate('valid_authority', .before = 'worms_sciname') %>%
  relocate(c('taxa_query', 'status', 'unacceptreason', 'is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_match, original_aphiaid, kingdom)))


# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
mollusca_freshterr_gen <- mollusca2 %>%
  filter(rank %in% c('species', 'genus')) %>%
  select(class, order, phylum, family, genus, worms_aphiaid, freshwater_only, terrestrial_only) %>%
  filter(freshwater_only == 1 | terrestrial_only == 1) %>%
  distinct(genus, .keep_all = TRUE)


# reassess not-found list again
mollusca_genera_fix <- mollusca_nf_worms %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname) %>%
  filter(!(found_taxa %in% mollusca_records$taxa_query)) %>%
  # extract genus names so we can test them
  separate(found_taxa, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(mollusca_freshterr_gen, by = c('genus_split' = 'genus')) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  rename(genus = genus_split) %>%
  mutate(rank = ifelse(str_detect(found_taxa, " ") == FALSE, 'genus', 'species'))

# bind generic resolutions
mollusca2 <- mollusca2 %>%
  bind_rows(mollusca_genera_fix)

# all molluscs here had NA for family

# family-level search
## typically this will be terrestrial or freshwater-only families
#mollusca_nf_families <- mollusca_nf_worms %>%
#  filter(!(taxa_query %in% mollusca2$taxa_query)) %>%
#  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname, family)


# ready to merge
write_csv(mollusca2, here(rosetta, 'problems', 'resolved', 
                                  '20220719_mollusca_worms_tol-resolved.csv'))
```
## Outstanding
```{r mollusc-outstanding}
# filter to who's left
mollusca_nf_worms2 <- mollusca_nf_worms %>%
  filter(!(taxa_query %in% mollusca2$taxa_query)) %>%
  select(taxa_query, found_taxa, ott_id, is_synonym, flags, tol_sciname, family)

# get higher taxonomy for these
mollusca_ottclassify <- classification(mollusca_nf_worms2$found_taxa, db = 'tol')

mollusca_nf_classify <- mollusca_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
  distinct()


#select only families to search
mollusca_nf_family <- mollusca_nf_classify %>%
  select(family) %>%
  filter(!(is.na(family))) %>%
  filter(!(family == 'NULL')) %>%
  distinct() 

# which families have worms ids?
mollusca_family <- get_wormsid_(mollusca_nf_family$family)

mollusca_family2 <- mollusca_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

mollusca_family_records <- search_records_worms(mollusca_family2$query)

#generate conflict list at family level
mollusca_problems2 <- mollusca_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  full_join(mollusca_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x) %>%
  rename(taxa_query = query) %>%
  mutate(across(c(ottid_species, phylum, class, order, family, genus), ~ as.character(.))) %>%
  distinct(taxa_query, .keep_all = TRUE)


# outstanding conflicts
write_csv(mollusca_problems2, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220719_mollusca_worms_tol-conflict-family.csv'))
```




# Echinoderms-Nemertea-Platyhelminthes

```{r}
ech_platy_nem_nf_worms <- read_csv(here(tol_conflict,
                                   '20220718_ech_platy_nem_worms-tol-conflict.csv'))[-1] %>%
  #clean found_taxa column
  mutate(found_taxa = str_remove_all(found_taxa, " \\(.*\\)")) %>%
  mutate(found_taxa = trimws(found_taxa))
```



```{r}
# make worms-searchable for temp issue
ech_platy_nem_search <- ech_platy_nem_nf_worms %>%
  select(c(found_taxa)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", found_taxa))

# first pass to find anything that shouod have been found
ech_platy_nem_worms_fuzzy <- get_wormsid_(ech_platy_nem_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
ech_platy_nem_worms2 <- ech_platy_nem_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
ech_platy_nem_worms2 <- ech_platy_nem_worms2 %>%
  left_join(ech_platy_nem_search, by = c('query' = 'worms_query')) %>%
  relocate(found_taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
ech_platy_nem_worms2 <- ech_platy_nem_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(found_taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(found_taxa == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
ech_platy_nem_records <- search_records_worms(ech_platy_nem_worms2$found_taxa)

# generate terrestrial-only and freshwater-only columns
ech_platy_nem_records <- ech_platy_nem_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

# gbif and bold ids
ech_platy_nem_bold <- get_boldid_(sci = ech_platy_nem_records$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
ech_platy_nem_bold2 <- map_dfr(.x= ech_platy_nem_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))
# GBIF id
ech_platy_nem_gbifid <- get_gbifid_(sci = ech_platy_nem_records$taxa_query, rows = 1)

ech_platy_nem_gbifid2 <- map_dfr(.x= ech_platy_nem_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


# join all updated fields
ech_platy_nem2 <- ech_platy_nem_nf_worms %>%
  select(taxa_query, ott_id, tol_sciname, is_synonym, flags) %>%
  left_join(ech_platy_nem_records) %>%
  left_join(ech_platy_nem_bold2) %>%
  left_join(ech_platy_nem_gbifid2) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank', 'phylum', 'class', 'order', 'family', 'genus'), .before = 'worms_aphiaid') %>%
  relocate('valid_authority', .before = 'worms_sciname') %>%
  relocate(c('taxa_query', 'status', 'unacceptreason', 'is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_match, original_aphiaid, kingdom)))


# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
ech_platy_nem_freshterr_gen <- ech_platy_nem2 %>%
  filter(rank %in% c('species', 'genus')) %>%
  select(class, order, phylum, family, genus, worms_aphiaid, freshwater_only, terrestrial_only) %>%
  filter(freshwater_only == 1 | terrestrial_only == 1) %>%
  distinct(genus, .keep_all = TRUE)


# reassess not-found list again
ech_platy_nem_genera_fix <- ech_platy_nem_nf_worms %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname) %>%
  filter(!(found_taxa %in% ech_platy_nem_records$taxa_query)) %>%
  # extract genus names so we can test them
  separate(found_taxa, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(ech_platy_nem_freshterr_gen, by = c('genus_split' = 'genus')) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  rename(genus = genus_split) %>%
  mutate(rank = ifelse(str_detect(found_taxa, " ") == FALSE, 'genus', 'species'))

# bind generic resolutions
ech_platy_nem2 <- ech_platy_nem2 %>%
  bind_rows(ech_platy_nem_genera_fix)



# all echinoderms/platyhelminthes/nemerteans here had NA for family, but keeping code for future use

# family-level search
## typically this will be terrestrial or freshwater-only families
#ech_platy_nem_nf_families <- ech_platy_nem_nf_worms %>%
#  filter(!(taxa_query %in% ech_platy_nem2$taxa_query)) %>%
#  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname, family)


# ready to merge
write_csv(ech_platy_nem2, here(rosetta, 'problems', 'resolved', 
                                  '20220719_ech_platy_nem_worms_tol-resolved.csv'))
```

```{r echplatynem-problems}
# filter to who's left
ech_platy_nem_nf_worms2 <- ech_platy_nem_nf_worms %>%
  filter(!(found_taxa %in% ech_platy_nem2$found_taxa)) %>%
  select(taxa_query, found_taxa, ott_id, is_synonym, flags, tol_sciname, family)

# get higher taxonomy for these
ech_platy_nem_ottclassify <- classification(ech_platy_nem_nf_worms2$found_taxa, db = 'tol')

ech_platy_nem_nf_classify <- ech_platy_nem_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
  distinct()


#select only families to search
ech_platy_nem_nf_family <- ech_platy_nem_nf_classify %>%
  select(family) %>%
  filter(!(is.na(family))) %>%
  filter(!(family == 'NULL')) %>%
  distinct()


# which families have worms ids?
ech_platy_nem_family <- get_wormsid_(ech_platy_nem_nf_family$family)

ech_platy_nem_family2 <- ech_platy_nem_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

ech_platy_nem_family_records <- search_records_worms(ech_platy_nem_family2$query)

#generate conflict list at family level
ech_platy_nem_problems2 <- ech_platy_nem_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  full_join(ech_platy_nem_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x) %>%
  rename(taxa_query = query) %>%
  mutate(across(c(ottid_species, phylum, class, order, family, genus), ~ as.character(.))) %>%
  distinct(taxa_query, .keep_all = TRUE)


# outstanding conflicts
write_csv(ech_platy_nem_problems2, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220720_ech_platy_nem_worms_tol-conflict-family.csv'))
```


# Small phyla

```{r sf-loadin}
smallphyla_nf_worms <- read_csv(here(tol_conflict,
                                   '20220718_small_phyla_worms-tol-conflict.csv'))[-1] %>%
  #clean found_taxa column
  mutate(found_taxa = str_remove_all(found_taxa, " \\(.*\\)")) %>%
  mutate(found_taxa = trimws(found_taxa))
```

```{r sf-fix}
# make worms-searchable for temp issue
smallphyla_search <- smallphyla_nf_worms %>%
  select(c(found_taxa)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", found_taxa))

# first pass to find anything that shouod have been found
smallphyla_worms_fuzzy <- get_wormsid_(smallphyla_search$worms_query, 
                                marine_only = FALSE, ask = FALSE,
                                accepted = FALSE)


# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
smallphyla_worms2 <- smallphyla_worms_fuzzy %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
smallphyla_worms2 <- smallphyla_worms2 %>%
  left_join(smallphyla_search, by = c('query' = 'worms_query')) %>%
  relocate(found_taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
smallphyla_worms2 <- smallphyla_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(found_taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(found_taxa == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# now use my loop to pull anything found
smallphyla_records <- search_records_worms(smallphyla_worms2$found_taxa)

# generate terrestrial-only and freshwater-only columns
smallphyla_records <- smallphyla_records %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

# gbif and bold ids
smallphyla_bold <- get_boldid_(sci = smallphyla_records$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
smallphyla_bold2 <- map_dfr(.x= smallphyla_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))
# GBIF id
smallphyla_gbifid <- get_gbifid_(sci = smallphyla_records$taxa_query, rows = 1)

smallphyla_gbifid2 <- map_dfr(.x= smallphyla_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


# join all updated fields
smallphyla2 <- smallphyla_nf_worms %>%
  select(taxa_query, ott_id, tol_sciname, is_synonym, flags) %>%
  left_join(smallphyla_records) %>%
  left_join(smallphyla_bold2) %>%
  left_join(smallphyla_gbifid2) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank', 'phylum', 'class', 'order', 'family', 'genus'), .before = 'worms_aphiaid') %>%
  relocate('valid_authority', .before = 'worms_sciname') %>%
  relocate(c('taxa_query', 'status', 'unacceptreason', 'is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_match, original_aphiaid, kingdom)))


# generate list of genera + terrestrial/marine status
## this will let us automatically classify some not-in-worms species
smallphyla_freshterr_gen <- smallphyla2 %>%
  filter(rank %in% c('species', 'genus')) %>%
  select(class, order, phylum, family, genus, worms_aphiaid, freshwater_only, terrestrial_only) %>%
  filter(freshwater_only == 1 | terrestrial_only == 1) %>%
  distinct(genus, .keep_all = TRUE)


# reassess not-found list again
smallphyla_genera_fix <- smallphyla_nf_worms %>%
  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname) %>%
  filter(!(found_taxa %in% smallphyla_records$taxa_query)) %>%
  # extract genus names so we can test them
  separate(found_taxa, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  left_join(smallphyla_freshterr_gen, by = c('genus_split' = 'genus')) %>%
  filter(!(is.na(worms_aphiaid))) %>%
  rename(genus = genus_split) %>%
  mutate(rank = ifelse(str_detect(found_taxa, " ") == FALSE, 'genus', 'species'))

# bind generic resolutions
smallphyla2 <- smallphyla2 %>%
  bind_rows(smallphyla_genera_fix)

# all small-phyla here had NA for family, but keeping code for future use

# family-level search
## typically this will be terrestrial or freshwater-only families
#smallphyla_nf_families <- smallphyla_nf_worms %>%
#  filter(!(taxa_query %in% smallphyla2$taxa_query)) %>%
#  select(taxa_query, ott_id, is_synonym, flags, found_taxa, tol_sciname, family)


#smallphyla_family_fix <- smallphyla2 %>%
#  filter(rank == 'family') %>%
#  select(!(c(ott_id, tol_sciname, flags, is_synonym, taxa_query, found_taxa))) %>%
#  distinct() %>%
#  right_join(smallphyla_nf_families) %>%
#  filter(!(is.na(worms_aphiaid))) %>%
  # any  marine-only or possibly marine taxa should be put on the actual-problems list
#  filter(freshwater_only == 1 | terrestrial_only == 1) %>%
  # these are all specific level IDs as generic level was resolved earlier
  ## rank should reflect this
#  mutate(rank = recode(rank, family = 'species'))

# bind family resolutions
#smallphyla2 <- smallphyla2 %>%
#  bind_rows(smallphyla_family_fix)



# ready to merge
write_csv(smallphyla2, here(rosetta, 'problems', 'resolved', 
                                  '20220719_smallphyla_worms_tol-resolved.csv'))
```
## outstanding problems
```{r sf-problems}
# filter to who's left
smallphyla_nf_worms2 <- smallphyla_nf_worms %>%
  filter(!(taxa_query %in% smallphyla2$taxa_query)) %>%
  select(taxa_query, found_taxa, ott_id, is_synonym, flags, tol_sciname, family)

# get higher taxonomy for these
smallphyla_ottclassify <- classification(smallphyla_nf_worms2$found_taxa, db = 'tol')

smallphyla_nf_classify <- smallphyla_ottclassify %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, phylum, class, subclass, order, family, genus, species, ottid_species)

#select only families to search
smallphyla_nf_family <- smallphyla_nf_classify %>%
  select(family) %>%
  filter(!(is.na(family))) %>%
  filter(!(family == 'NULL')) %>%
  distinct() %>%
  # fix or remove odd strings
  mutate(family = str_remove_all(family, 'c\\(\\"Pelagiidae\\", \\"Pelagiidae\\"\\)')) %>%
  filter(!(family == ''))

# which families have worms ids?
smallphyla_family <- get_wormsid_(smallphyla_nf_family$family)

smallphyla_family2 <- smallphyla_family %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(!(query == scientificname)))

smallphyla_family_records <- search_records_worms(smallphyla_family2$query)

#generate conflict list at family level
smallphyla_problems2 <- smallphyla_nf_classify %>%
  select(query, family, ottid_species) %>%
  mutate(family = as.character(family)) %>%
  full_join(smallphyla_family_records, by = 'family') %>%
  select(!(query.y)) %>%
  rename(query = query.x) %>%
  rename(taxa_query = query) %>%
  mutate(across(c(ottid_species, phylum, class, order, family, genus), ~ as.character(.))) %>%
  distinct(taxa_query, .keep_all = TRUE)


# outstanding conflicts
write_csv(smallphyla_problems2, here(rosetta, 'problems', 'tol_conflict', 
                                  '20220720_smallphyla_worms_tol-conflict-family.csv'))
```



# Scratch work
```{r scratch2}
### add this to the merge document with teh final database since the main db has this info too!

#extract list of terrestrial/fresh onlys
annelid_terrfresh <- annelid_nf_worms2 %>%
  filter(terrestrial_only == 1 | freshwater_only == 1)
```

