---
title: "12s_Mifish_01_taxize"
author: "Kate Sheridan"
date: '2022-07-13'
output: html_document
---

This uses the Midori RDP classifier list
This will include more than fish, but 12S Mifish does pick up more than fish anyway.

The Midori classifier does have taxonomy built in, but we want the output to match the COI output, and especially WoRMS taxonomy. Assumedly, there will be a lot here with only OTT codes as few of the non-fish vertebrates will be marine.

```{r setup, include=FALSE}
library(tidyverse)
library(stringr)
library(taxize)
library(here)

# here filepaths
hakai_blast <- here('species_lists', 'hakai', '2021_blast-db')
rosetta <- here('species_lists', 'hakai', '2022rosetta')
```

```{r load-in}
midori <- read_csv(here(hakai_blast, '20211216_midori_all_sp.csv'))
```

```{r tol_resolve}
midori_key <- midori %>%
  select(species) %>%
  mutate(species_verbatim = species) %>%
  # remove 'sp'
  mutate(species = str_remove_all(species, c("( sp)$"))) %>%
  mutate(species = str_remove_all(species, " sp[0-9]")) %>%
  mutate(species = str_remove_all(species, " sensu lato")) %>%
  mutate(species = str_remove_all(species, " sesu lato")) %>%
  mutate(species = str_remove_all(species, " sensu stricto")) %>%
  mutate(species = str_remove_all(species, " genotype")) %>%
  mutate(species = str_remove_all(species, " group")) %>%
  mutate(species = str_remove_all(species, " lineage")) %>%
  # remove brackets, still getting the odd behavior in one call?
  mutate(species = str_remove_all(species, "\\[")) %>%
  mutate(species = str_remove_all(species, "\\]")) %>%
  # a few known strings
  # remove all numbers
  mutate(species = str_remove_all(species, "[0-9]")) %>%
  mutate(species = trimws(species)) %>%
  #remove the last character if its a capital letter many times
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  # in case multiple 'words'
  mutate(species = trimws(species)) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  #any sp that is left?
  mutate(species = str_remove_all(species, "( sp)$")) %>%
  # specific strings that are left
  mutate(species = str_remove_all(species, "( AHSp)$")) %>%
  mutate(species = str_remove_all(species, "( CAhyb)$")) %>%
  mutate(species = str_remove_all(species, "( Rs)$")) %>%
  mutate(species = str_remove_all(species, "( SCa)$")) %>%
  mutate(species = str_remove_all(species, "( SAc)")) %>%
  mutate(species = str_remove_all(species, "( SAg)")) %>%
  mutate(species = str_remove_all(species, "( SHo)")) %>%
  mutate(species = str_remove_all(species, "( SIm)$")) %>%
  mutate(species = str_remove_all(species, "( SSg)")) %>%
  mutate(species = str_remove_all(species, "( Ssp)")) %>%
  mutate(species = str_remove_all(species, "( Ste)$")) %>%
  mutate(species = str_remove_all(species, "( STi)$")) %>%
  mutate(species = str_remove_all(species, "( Tas)$")) %>%
  mutate(species = str_remove_all(species, "( Hmargsl)$")) %>%
  mutate(species = str_remove_all(species, "( Hyp)$")) %>%
  mutate(species = str_remove_all(species, "( [a-z]{1})$")) %>%
  mutate(species = str_remove_all(species, "^fossil")) %>%
  mutate(species = str_remove_all(species, "(unnamed genus  penumbrata sensu Scoble)$")) %>%
  mutate(species = str_replace_all(species, 
                                   c('mycorrhizal symbiont of Neuwiedia veratrifolia' = 'Fungi',
                                     'mycorrhizal isolate' = 'Fungi',
                                     'orange sea anemone' = 'Actiniaria',
                                     'hormathiid anemone strain VenAnem' = 'Hormathiidae',
                                              'tophaceataAHIt' = 'tophaceata',
                                     'liliputanusg' = 'liliputanus'))) %>%
  # remove trailing whitespaces
  mutate(species = trimws(species)) %>%
  distinct()


midori_search <- midori_key %>%
  select(species) %>%
  distinct()


#split into smaller sections to guarantee finishing

msearch1 <- midori_search[1:7000,]
msearch2 <- midori_search[7001:30000,]
msearch3 <- midori_search[30001:60000,]
msearch4 <- midori_search[60001:100000,]
msearch5 <- midori_search[100001:140000,]
msearch6 <- midori_search[140001:180000,]
msearch7 <- midori_search[180001:210000,]
msearch8 <- midori_search[210001:245519,]

#temp
#msearch9 <- midori_search %>%
#  filter(!(species %in% mresolved$search_string))


# resolve with open tree of life, all domains to filter out fungi, etc.
midori_resolved <- tol_resolve(msearch8$species) %>%
  mutate(search_string = str_to_sentence(search_string))


# manually set temp variables to merge later
#mresolved1 <- midori_resolved
#mresolved2 <- midori_resolved
#mresolved3 <- midori_resolved
#mresolved4 <- midori_resolved
#mresolved5 <- midori_resolved
#mresolved6 <- midori_resolved
#mresolved7 <- midori_resolved
mresolved8 <- midori_resolved
#temp
#mresolved9 <- midori_resolved


mresolved <- mresolved1 %>%
  bind_rows(mresolved2, mresolved3, mresolved4,
            mresolved5, mresolved6, mresolved7,
            mresolved8#, mresolved9
            )

#save intermediate just in case!
#write_rds(mresolved, here('temp_midori.rds'))
mresolved <- readRDS(here('temp_midori.rds'))

# classify found IDs, will probably need split again

midori_notfound <- mresolved %>%
  filter(is.na(unique_name))

# sort out unique names
mresolved_classify <- mresolved %>%
  filter(!(is.na(unique_name))) %>% 
  select(unique_name) %>%
  distinct()

#for some reason its a 'match.names' object 
mresolved_classify <- as.tibble(mresolved_classify)


# do the splitting-babysitting-thing again
mresolved_classify1 <- mresolved_classify[1:7000,]
mresolved_classify2 <- mresolved_classify[7001:30000,]
mresolved_classify3 <- mresolved_classify[30001:60000,]
mresolved_classify4 <- mresolved_classify[60001:100000,]
mresolved_classify5 <- mresolved_classify[100001:140000,]
mresolved_classify6 <- mresolved_classify[140001:180000,]
mresolved_classify7 <- mresolved_classify[180001:210000,]
mresolved_classify8 <- mresolved_classify[210001:238338,]

midori_classify <- classification(mresolved_classify5$unique_name, db = 'tol')

# manually set temp variables to merge later
#mclassify1 <- midori_classify
#mclassify2 <- midori_classify
#mclassify3 <- midori_classify
#mclassify4 <- midori_classify
mclassify5 <- midori_classify
#mclassify6 <- midori_classify
#mclassify7 <- midori_classify
#mclassify8 <- midori_classify


#save temp versions in case it breaks again
write_rds(mclassify5, here('temp_midori_c5.rds'))
write_rds(mclassify6, here('temp_midori_c6.rds'))
write_rds(mclassify7, here('temp_midori_c7.rds'))
write_rds(mclassify8, here('temp_midori_c8.rds'))


#bind rows and save again
```

## Problems

Anything not found needs resolved
Here we're running what TOL didn't find through several databases to identify them. In the COI script, we would have run it through WORMS here but we don't have it filtered to marine species yet.
Anything found is classified by the respective database, because at this stage we're looking to filter out not-fish. Then the remaining fish will be stripped of higher taxonomy and run through worms.

```{r problems}
# extract 'failures'
# mresolved9 is a rerun list of not-found
# in a future version we'll replace this with a filtered object
## filtered object made, redo this section with midori_notfound
mresolved_fail <- mresolved9 %>%
  filter(is.na(unique_name))

# run through gbif
mresolve_gbif <- get_gbifid_(sci = mresolved_fail$search_string)

mresolve_gbif2 <- map_dfr(.x= mresolve_gbif, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(scientificname, status, confidence, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_taxa = canonicalname)
  
mresolved_fail <- mresolved_fail %>%
  filter(!(search_string %in% mresolve_gbif2$taxa_query))

# run through BOLD
mresolve_bold <- get_boldid_(sci = mresolved_fail$search_string)

mresolve_bold2 <- map_dfr(.x= mresolve_bold, ~ data.frame(.x), .id = 'taxa_query') %>%
    rename(bold_taxa = input)

# classify found with bold
mresolve_bold_classify <- classification(mresolve_bold2$bold_taxa, db = 'bold')

mresolve_bold_classify2 <- map_dfr(.x= mresolve_bold_classify, ~ data.frame(.x), 
                                   .id = 'taxa_query') %>%
  distinct() %>%
  pivot_wider(names_from = rank, values_from = name, id_cols = taxa_query)


mresolved_fail <- mresolved_fail %>%
  filter(!(search_string %in% mresolve_bold2$taxa_query))


# now we'll extract the first word in each taxa here, presumably the genus, and try searching that way.
## Many of these issues are with insects, and what really matters is that we can sort out insects from our results.

mresolved_fail_gen <- mresolved_fail %>%
  select(search_string) %>%
  # extract genus names so we can test them
  separate(search_string, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  # remove brackets?
  mutate(genus_split = str_remove_all(genus_split, "[\\[\\]]")) 

fail_gen_search <- mresolved_fail_gen %>%
  select(genus_split)%>%
  distinct()

# run through gbif
mresolve_gbif_gen <- get_gbifid_(sci = fail_gen_search$genus_split)

#rotate and prep
mresolve_gbif_gen2 <- map_dfr(.x= mresolve_gbif_gen, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(scientificname, status, confidence, matchtype, kingdomkey,
             phylumkey, orderkey,
             classkey, familykey, genuskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_taxa = canonicalname,
         genus_split = taxa_query)
  
mresolved_gbif_gen3 <- mresolved_fail_gen %>%
  left_join(mresolve_gbif_gen2, by = 'genus_split') %>%
  filter(!(is.na(gbif_key)))

mresolved_fail_gen <-mresolved_fail_gen %>%
  filter(!(genus_split %in% mresolved_gbif_gen3$genus_split))

fail_gen_search <- fail_gen_search %>%
  filter(genus_split %in% mresolved_fail_gen$genus_split)




# EOL
# eol has some of the ncbi entries that can be odd
## find ID's and classify
mresolve_eol_gen <- get_eolid_(fail_gen_search$genus_split)
mresolve_eol_gen2 <- map_dfr(.x= mresolve_eol_gen, ~ data.frame(.x), .id = 'taxa_query')

mresolve_eol_classify <- classification(mresolve_eol_gen2$eolid, db = 'eol')

# rotate and clean
mresolve_eol_class2 <- map_dfr(.x = mresolve_eol_classify, ~ data.frame(.x), .id = 'eolid') %>%
  # fix the entries that doesn't have ranks 
  mutate(rank = ifelse(name %in% c('Fungi'), 'kingdom', rank)) %>%
  mutate(rank = ifelse(name %in% c('Arthropoda', 'Chordata'), 'phylum', rank)) %>%
  mutate(rank = ifelse(name %in% c('Insecta', 'Reptilia'), 'class', rank)) %>%
  mutate(rank = ifelse(name %in% c('Disholandricus', 'Rossmanomyces',
                                   'Ornithuroscincus'), 'genus', rank)) %>%
  filter(rank %in% c('kingdom', 'phylum', 'class', 
                     'order', 'family', 'genus', 'species')) %>%
  select(!(id)) %>%
  filter(!(name %in% c('Dipnotetrapodomorpha', 'Sarcopterygii'))) %>%
  distinct() %>%
  pivot_wider(id_cols = eolid, names_from = rank, values_from = name) %>%
  select(!(c(species))) %>%
  distinct(genus, .keep_all = TRUE) %>%
  filter(!(is.na(genus))) %>%
  rename(genus_split = genus)


mresolved_fail_gen2 <- mresolved_fail_gen %>%
  left_join(mresolve_eol_class2, by = 'genus_split') %>%
  filter(!(is.na(eolid))) %>%
  rename(taxa_query = search_string)

## extract what's still failing to look at later
outstanding_fails <- mresolved_fail_gen %>%
  filter(!(search_string %in% mresolved_fail_gen2$taxa_query))

write_csv(outstanding_fails, here(rosetta, 'problems',
                                  'not_found', '20220718_midori_mifish_notfound.csv'))

# consolidate problems
problems_classified <- mresolve_gbif2 %>%
  bind_rows(mresolve_gbif_gen2, mresolve_bold_classify2, 
            mresolved_fail_gen2) %>%
  mutate(kingdom = ifelse(phylum %in% c('Annelida', 'Arthropoda', 'Chordata',
                                        'Cnidaria', 'Mollusca', 'Nematoda',
                                        'Tardigrada'), 
                          'Animalia', kingdom)) %>%
  # just in case any slipped through
  filter(!(taxa_query %in% outstanding_fails$search_string))



```



