---
title: "12s_Mifish_01_taxize"
author: "Kate Sheridan"
date: '2022-07-13'
output: html_document
---

This uses the Midori RDP classifier list
This will include more than fish, but 12S Mifish does pick up more than fish anyway.

The Midori classifier does have taxonomy built in, but we want the output to match the COI output, and especially WoRMS taxonomy. Assumedly, there will be a lot here with only OTT codes as few of the non-fish vertebrates will be marine.

```{r setup, include=FALSE}
library(tidyverse)
library(stringr)
library(taxize)
library(here)

# here filepaths
hakai_blast <- here('species_lists', 'hakai', '2021_blast-db')
rosetta <- here('species_lists', 'hakai', '2022rosetta')
```

```{r load-in}
midori <- read_csv(here(hakai_blast, '20211216_midori_all_sp.csv'))
```

```{r classify-exand}
# classify expand function
classify_expand <- function(classifyobject) {
  expanded_classify <- classifyobject %>% 
  compact() %>%
  #discard( ~ nrow(.x) == 0) %>% # this caused issues in some of the lists?
  map_dfr( ~ data.frame(.x), .id = 'query') %>%
  filter(!(rank == 'no rank')) %>%
  pivot_wider(id_cols = query, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'ottid_')) %>%
  select(query, domain, kingdom, phylum, class, subclass, 
         order, family, genus, species, ottid_species) %>%
  # some of these come back with c() inside the cells, we'll unbind them
  mutate(across(.fns = ~gsub('c\\(|\\)', '', .))) %>%
  mutate(across(.fns = ~gsub('\"', '', .))) %>%
  separate_rows(phylum, class, subclass, order, family, 
                genus, species, ottid_species,
                sep = ", ") %>%
    distinct() %>%
    mutate(across(.cols = everything(), ~str_replace_all(., 'NULL', NA_character_)))
  return(expanded_classify)
}
```




```{r tol_resolve}
midori_key <- midori %>%
  select(species) %>%
  mutate(species_verbatim = species) %>%
  # remove 'sp'
  mutate(species = str_remove_all(species, c("( sp)$"))) %>%
  mutate(species = str_remove_all(species, " sp[0-9]")) %>%
  mutate(species = str_remove_all(species, " sensu lato")) %>%
  mutate(species = str_remove_all(species, " sesu lato")) %>%
  mutate(species = str_remove_all(species, " sensu stricto")) %>%
  mutate(species = str_remove_all(species, " genotype")) %>%
  mutate(species = str_remove_all(species, " group")) %>%
  mutate(species = str_remove_all(species, " lineage")) %>%
  # remove brackets, still getting the odd behavior in one call?
  mutate(species = str_remove_all(species, "\\[")) %>%
  mutate(species = str_remove_all(species, "\\]")) %>%
  # a few known strings
  # remove all numbers
  mutate(species = str_remove_all(species, "[0-9]")) %>%
  mutate(species = trimws(species)) %>%
  #remove the last character if its a capital letter many times
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  # in case multiple 'words'
  mutate(species = trimws(species)) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  mutate(species = str_remove_all(species, "([A-Z])$")) %>%
  #any sp that is left?
  mutate(species = str_remove_all(species, "( sp)$")) %>%
  # specific strings that are left
  mutate(species = str_remove_all(species, "( AHSp)$")) %>%
  mutate(species = str_remove_all(species, "( CAhyb)$")) %>%
  mutate(species = str_remove_all(species, "( Rs)$")) %>%
  mutate(species = str_remove_all(species, "( SCa)$")) %>%
  mutate(species = str_remove_all(species, "( SAc)")) %>%
  mutate(species = str_remove_all(species, "( SAg)")) %>%
  mutate(species = str_remove_all(species, "( SHo)")) %>%
  mutate(species = str_remove_all(species, "( SIm)$")) %>%
  mutate(species = str_remove_all(species, "( SSg)")) %>%
  mutate(species = str_remove_all(species, "( Ssp)")) %>%
  mutate(species = str_remove_all(species, "( Ste)$")) %>%
  mutate(species = str_remove_all(species, "( STi)$")) %>%
  mutate(species = str_remove_all(species, "( Tas)$")) %>%
  mutate(species = str_remove_all(species, "( Hmargsl)$")) %>%
  mutate(species = str_remove_all(species, "( Hyp)$")) %>%
  mutate(species = str_remove_all(species, "( [a-z]{1})$")) %>%
  mutate(species = str_remove_all(species, "^fossil")) %>%
  mutate(species = str_remove_all(species, "(unnamed genus  penumbrata sensu Scoble)$")) %>%
  mutate(species = str_replace_all(species, 
                                   c('mycorrhizal symbiont of Neuwiedia veratrifolia' = 'Fungi',
                                     'mycorrhizal isolate' = 'Fungi',
                                     'orange sea anemone' = 'Actiniaria',
                                     'hormathiid anemone strain VenAnem' = 'Hormathiidae',
                                              'tophaceataAHIt' = 'tophaceata',
                                     'liliputanusg' = 'liliputanus'))) %>%
  # remove trailing whitespaces
  mutate(species = trimws(species)) %>%
  distinct()


midori_search <- midori_key %>%
  select(species) %>%
  distinct()


#split into smaller sections to guarantee finishing

msearch1 <- midori_search[1:7000,]
msearch2 <- midori_search[7001:30000,]
msearch3 <- midori_search[30001:60000,]
msearch4 <- midori_search[60001:100000,]
msearch5 <- midori_search[100001:140000,]
msearch6 <- midori_search[140001:180000,]
msearch7 <- midori_search[180001:210000,]
msearch8 <- midori_search[210001:245519,]

#temp
#msearch9 <- midori_search %>%
#  filter(!(species %in% mresolved$search_string))


# resolve with open tree of life, all domains to filter out fungi, etc.
midori_resolved <- tol_resolve(msearch8$species) %>%
  mutate(search_string = str_to_sentence(search_string))


# manually set temp variables to merge later
#mresolved1 <- midori_resolved
#mresolved2 <- midori_resolved
#mresolved3 <- midori_resolved
#mresolved4 <- midori_resolved
#mresolved5 <- midori_resolved
#mresolved6 <- midori_resolved
#mresolved7 <- midori_resolved
mresolved8 <- midori_resolved
#temp
#mresolved9 <- midori_resolved


mresolved <- mresolved1 %>%
  bind_rows(mresolved2, mresolved3, mresolved4,
            mresolved5, mresolved6, mresolved7,
            mresolved8#, mresolved9
            )

#save intermediate just in case!
#write_rds(mresolved, here('temp_midori.rds'))
#mresolved <- readRDS(here('temp_midori.rds'))

# sort out unique names
mresolved_classify <- mresolved %>%
  filter(!(is.na(unique_name))) %>% 
  select(unique_name) %>%
  distinct()

#for some reason its a 'match.names' object 
mresolved_classify <- as.tibble(mresolved_classify)


# do the splitting-babysitting-thing again
mresolved_classify1 <- mresolved_classify[1:7000,]
mresolved_classify2a <- mresolved_classify[7001:20000,]
mresolved_classify2b <- mresolved_classify[21001:30000,]
mresolved_classify3a <- mresolved_classify[30001:40000,]
mresolved_classify3b <- mresolved_classify[40001:50000,]
mresolved_classify3c <- mresolved_classify[50001:60000,]
mresolved_classify4a <- mresolved_classify[60001:70000,]
mresolved_classify4b <- mresolved_classify[70001:80000,]
mresolved_classify4c <- mresolved_classify[80001:90000,]
mresolved_classify4d <- mresolved_classify[90001:100000,]
mresolved_classify5 <- mresolved_classify[100001:140000,]
mresolved_classify6 <- mresolved_classify[140001:180000,]
mresolved_classify7 <- mresolved_classify[180001:210000,]
mresolved_classify8 <- mresolved_classify[210001:238338,]

midori_classify <- classification(mresolved_classify4d$unique_name, db = 'tol')

# manually set temp variables to merge later
#mclassify1 <- midori_classify
#mclassify2a <- midori_classify
#mclassify2b <- midori_classify
#mclassify3a <- midori_classify
#mclassify3b <- midori_classify
#mclassify3c <- midori_classify
#mclassify4a <- midori_classify
#mclassify4b <- midori_classify
#mclassify4c <- midori_classify
mclassify4d <- midori_classify
#mclassify5 <- midori_classify
#mclassify6 <- midori_classify
#mclassify7 <- midori_classify
#mclassify8 <- midori_classify


#save temp versions in case it breaks again
#write_rds(mclassify1, here('temp_midori1.rds'))
#write_rds(mclassify2a, here('temp_midori2a.rds'))
#write_rds(mclassify2b, here('temp_midori2b.rds'))
#write_rds(mclassify3a, here('temp_midori3a.rds'))
#write_rds(mclassify3b, here('temp_midori3b.rds'))
#write_rds(mclassify3c, here('temp_midori3c.rds'))
#write_rds(mclassify4a, here('temp_midori4a.rds'))
#write_rds(mclassify4b, here('temp_midori4b.rds'))
#write_rds(mclassify4c, here('temp_midori4c.rds'))
write_rds(mclassify4d, here('temp_midori4d.rds'))
write_rds(mclassify5, here('temp_midori_c5.rds'))
write_rds(mclassify6, here('temp_midori_c6.rds'))
write_rds(mclassify7, here('temp_midori_c7.rds'))
write_rds(mclassify8, here('temp_midori_c8.rds'))


mclassify1 <- readRDS(here('temp_midori1.rds'))
mclassify2a <- readRDS(here('temp_midori2a.rds'))
mclassify2b <- readRDS(here('temp_midori2b.rds'))
mclassify3a <- readRDS(here('temp_midori3a.rds'))
mclassify3b <- readRDS(here('temp_midori3b.rds'))
mclassify3c <- readRDS(here('temp_midori3c.rds'))
mclassify4a <- readRDS(here('temp_midori4a.rds'))
mclassify4b <- readRDS(here('temp_midori4b.rds'))
mclassify4c <- readRDS(here('temp_midori4c.rds'))
mclassify4d <- readRDS(here('temp_midori4d.rds'))
mclassify5 <- readRDS(here('temp_midori_c5.rds'))
mclassify6 <- readRDS(here('temp_midori_c6.rds'))
mclassify7 <- readRDS(here('temp_midori_c7.rds'))
mclassify8 <- readRDS(here('temp_midori_c8.rds'))

# expand classificaction objects
mclassify1 <- classify_expand(mclassify1)
mclassify2a <- classify_expand(mclassify2a)
mclassify2b <- classify_expand(mclassify2b)
mclassify3a <- classify_expand(mclassify3a)
mclassify3b <- classify_expand(mclassify3b)
mclassify3c <- classify_expand(mclassify3c)
mclassify4a <- classify_expand(mclassify4a)
mclassify4b <- classify_expand(mclassify4b)
mclassify4c <- classify_expand(mclassify4c)
mclassify4d <- classify_expand(mclassify4d)
mclassify5 <- classify_expand(mclassify5)
mclassify6 <- classify_expand(mclassify6)
mclassify7 <- classify_expand(mclassify7)
mclassify8 <- classify_expand(mclassify8)



#bind rows and save again

mclassify_all <- mclassify1 %>%
  bind_rows(mclassify2a, mclassify2b, mclassify3a,
            mclassify3b, mclassify3c, mclassify4a,
            mclassify4b, mclassify4c, mclassify4d,
            mclassify5, mclassify6, mclassify7, mclassify8) %>%
  # clean up tol mess, nothing after the parentheses ever matters
  mutate(query = str_remove_all(query, '\\(.*')) %>%
  mutate(query = trimws(query)) %>%
    #remove duplicates, its ok if it isn't perfect
  distinct(query, kingdom, .keep_all = TRUE)

#write draft
write.csv(mclassify_all, here(rosetta, 'current_draft', '20220724_midori_taxonomy_all.csv'))
```

## Problems

Anything not found needs resolved
Here we're running what TOL didn't find through several databases to identify them. In the COI script, we would have run it through WORMS here but we don't have it filtered to marine species yet.
Anything found is classified by the respective database, because at this stage we're looking to filter out not-fish. Then the remaining fish will be stripped of higher taxonomy and run through worms.

```{r problems}
# read in draft if necessary
mclassify_all <- read_csv(here(rosetta, 'current_draft', '20220724_midori_taxonomy_all.csv'))[-1]

# extract 'failures'
mresolved_fail_full <- midori_search %>%
  filter(!(species %in% mclassify_all$query))

# object to use as rolling list
mresolved_fail <- mresolved_fail_full

# run through gbif instead
mresolve_gbif <- get_gbifid_(sci = mresolved_fail$species)

mresolve_gbif2 <- map_dfr(.x= mresolve_gbif, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(scientificname, status, confidence, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_taxa = canonicalname)
  
mresolved_fail <- mresolved_fail %>%
  filter(!(species %in% mresolve_gbif2$taxa_query))

# run through BOLD
mresolve_bold <- get_boldid_(sci = mresolved_fail$species)

mresolve_bold2 <- map_dfr(.x= mresolve_bold, ~ data.frame(.x), .id = 'taxa_query') %>%
    rename(bold_taxa = input) %>%
  filter(!(is.na(taxid)))

# classify found with bold
mresolve_bold_classify <- classification(mresolve_bold2$bold_taxa, db = 'bold')

mresolve_bold_classify2 <- map_dfr(.x= mresolve_bold_classify, ~ data.frame(.x), 
                                   .id = 'taxa_query') %>%
  distinct() %>%
  pivot_wider(names_from = rank, values_from = name, id_cols = taxa_query) %>%
  # make sure animals are populated here, the others don't matter anyway.
  mutate(kingdom = case_when(phylum == 'Arthropoda' ~ 'Animalia',
                             phylum == 'Annelida' ~ 'Animalia',
                             phylum == 'Cnidaria' ~ 'Animalia',
                             phylum == 'Chordata' ~ 'Animalia',
                             phylum == 'Mollusca' ~ 'Animalia',
                             phylum == 'Nemertea' ~ 'Animalia',
                             phylum == 'Platyhelminthes' ~ 'Animalia',
                             phylum == 'Tardigrada' ~ 'Animalia',
                             phylum == 'Nematoda' ~ 'Animalia')) %>%
  mutate(rank = 'species')


mresolved_fail <- mresolved_fail %>%
  filter(!(species %in% mresolve_bold2$taxa_query))


# now we'll extract the first word in each taxa here, presumably the genus, and try searching that way.
## Many of these issues are with insects, and what really matters is that we can sort out insects from our results.

mresolved_fail_gen_full <- mresolved_fail %>%
  # extract genus names so we can test them
  separate(species, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop') %>%
  # remove brackets?
  mutate(genus_split = str_remove_all(genus_split, "[\\[\\]]"))

#temp to use as rolling list
mresolved_fail_gen <- mresolved_fail_gen_full

fail_gen_search <- mresolved_fail_gen %>%
  select(genus_split)%>%
  distinct()

# run through gbif
mresolve_gbif_gen <- get_gbifid_(sci = fail_gen_search$genus_split)

#rotate and prep
mresolve_gbif_gen2 <- map_dfr(.x= mresolve_gbif_gen, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(scientificname, status, confidence, matchtype, kingdomkey,
             phylumkey, orderkey,
             classkey, familykey, genuskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_taxa = canonicalname,
         genus_split = taxa_query)
  
mresolved_gbif_gen3 <- mresolved_fail_gen %>%
  left_join(mresolve_gbif_gen2, by = 'genus_split') %>%
  filter(!(is.na(gbif_key))) %>%
  select(!(c(species.y, specieskey))) %>%
  rename(species = species.x)

mresolved_fail_gen <-mresolved_fail_gen %>%
  filter(!(genus_split %in% mresolved_gbif_gen3$genus_split))

fail_gen_search <- fail_gen_search %>%
  filter(genus_split %in% mresolved_fail_gen$genus_split)

# run through BOLD
mresolve_bold_gen <- get_boldid_(sci = fail_gen_search$genus_split)

mresolve_bold_gen2 <- map_dfr(.x= mresolve_bold_gen, ~ data.frame(.x), .id = 'taxa_query') %>%
    rename(bold_taxa = input) %>%
  filter(!(is.na(taxid))) %>%
  select(taxa_query) %>%
  distinct()

# classify found with bold
mresolve_bold_classify <- classification(mresolve_bold_gen12$taxa_query, db = 'bold')

mresolve_bold_classify_gen2 <- map_dfr(.x= mresolve_bold_classify, ~ data.frame(.x), 
                                   .id = 'taxa_query') %>%
  distinct() %>%
  pivot_wider(names_from = rank, values_from = name, id_cols = taxa_query) %>%
  rename(genus_split = taxa_query) %>%
  select(!(species)) %>%
  right_join(mresolved_fail_gen_full) %>%
  filter(!(is.na(phylum)))

mresolved_fail_gen <-mresolved_fail_gen %>%
  filter(!(genus_split %in% mresolve_bold_classify_gen2$genus_split))

fail_gen_search <- fail_gen_search %>%
  filter(genus_split %in% mresolved_fail_gen$genus_split)


# EOL
# eol has some of the ncbi entries that can be odd
## find ID's and classify
mresolve_eol_gen <- get_eolid_(fail_gen_search$genus_split)
mresolve_eol_gen2 <- map_dfr(.x= mresolve_eol_gen, ~ data.frame(.x), .id = 'taxa_query')

mresolve_eol_classify <- classification(mresolve_eol_gen2$eolid, db = 'eol')

# rotate and clean
mresolve_eol_class2 <- map_dfr(.x = mresolve_eol_classify, ~ data.frame(.x), .id = 'eolid') %>%
  # fix the entries that doesn't have ranks 
  mutate(rank = ifelse(name %in% c('Fungi', 'Plantae', 'Metazoa', 'Animalia', 'Viruses'), 'kingdom', rank)) %>%
  mutate(rank = ifelse(name %in% c('Arthropoda', 'Chordata'), 'phylum', rank)) %>%
  mutate(rank = ifelse(name %in% c('Insecta', 'Reptilia'), 'class', rank)) %>%
    mutate(rank = ifelse(name %in% c('Coleoptera'), 'order', rank)) %>%
  mutate(rank = ifelse(name %in% c('Disholandricus', 'Rossmanomyces',
                                   'Ornithuroscincus'), 'genus', rank)) %>%
  filter(rank %in% c('kingdom', 'phylum', 'class', 
                     'order', 'family', 'genus', 'species')) %>%
  select(!(c(id, `.x`))) %>%
  filter(!(name %in% c('Dipnotetrapodomorpha', 'Sarcopterygii'))) %>%
  distinct() %>%
  pivot_wider(id_cols = eolid, names_from = rank, values_from = name) %>%
  select(!(c(species))) %>%
  mutate(genus = str_remove_all(genus, " .*")) %>%
  distinct(genus, .keep_all = TRUE) %>%
  mutate(across(.cols = everything(), ~str_replace_all(., 'NULL', NA_character_))) %>%
  filter(!(is.na(genus))) %>%
  rename(genus_split = genus) %>%
  right_join(mresolved_fail_gen_full) %>%
  filter(!(is.na(eolid)))




# Combine all found lists
## NOTE this introduces errors with duplicates. 
## HOWEVER it is enough to filter to fish
mresolved_fail_gen2 <- mresolved_gbif_gen3 %>%
  bind_rows(mresolve_eol_class2, mresolve_bold_gen2) %>%
  select(!(c(gbif_key, acceptedusagekey, eolid, taxa_query))) %>%
  filter(genus_split == genus) %>%
  distinct(species, class, .keep_all = TRUE) %>%
  select(!(genus_split)) %>%
  bind_rows(mresolve_gbif2, mresolve_bold_classify2) %>%
  select(!(c(gbif_key, taxa_query, tribe, gbif_taxa, subfamily))) %>%
  filter(!(is.na(species))) %>%
  mutate(query = species)

## extract what's still failing to look at later
outstanding_fails <- mresolved_fail_full %>%
  filter(!(species %in% mresolved_fail_gen2$species))

write_csv(outstanding_fails, here(rosetta, 'problems',
                                  'not_found', '20220724_midori_mifish_notfound.csv'))

```

# combine problems and fixed
```{r}
midori_key2 <- midori_key %>%
  rename(query = species)

midori_all <- mclassify_all %>%
  bind_rows(mresolved_fail_gen2) %>%
  left_join(midori_key2) %>%
  relocate(species_verbatim)

write_csv(midori_all, here(rosetta, 'current_draft', '20220724_midori_all_draft.csv'))


# extract fish to fix up

midori_fish <- midori_all %>%
  filter(phylum == 'Chordata') %>%
  filter(class %in% c('Actinopteri', 'Chondrichthyes', 'Elasmobranchii',
                      'Dipnoi', 'Hyperotreti', 'Cladista', 'Myxini',
                      'Cephalaspidomorphi', NA)) %>%
  filter(!(order %in% c('Sauria')))

write_csv(midori_fish, here(rosetta, 'current_draft', '20220724_mifish_fish_filter.csv'))
```

