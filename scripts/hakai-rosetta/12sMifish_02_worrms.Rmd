---
title: "Untitled"
author: "Kate Sheridan"
date: "7/23/2022"
output: html_document
---

# Mifish Fish

Here we are going to run the fish we got from the last script through WoRMS
-

The pipeline for all groups is:
1: WoRMS for higher taxonomy
2: BOLD
3: fetching gbif ids
4 fetching OTL ids
5: list of not-found

```{r setup, include=FALSE}
library(tidyverse)
library(stringr)
library(taxize)
library(here)

# here filepaths
hakai_blast <- here('species_lists', 'hakai', '2021_blast-db')
rosetta <- here('species_lists', 'hakai', '2022rosetta')
```

```{r load-in}
midori_fish <- read_csv(here(rosetta, 'current_draft', 
                             '20220724_mifish_fish_filter.csv'))
```


```{r worms-function}
library(worrms)

## requires worrms to be loaded
# input is vector of species names
# use wm_records_names to extract 
# this doesn't need the + signs

# right now this breaks if not-found
search_records_worms <- function(spnames) {
  search <- tibble()
  for (i in spnames) {
    print(paste0('searching for ', i))
    record <- wm_records_names(i, marine_only = FALSE)
    message('done')
    search <- append(search, record)
  }
  names(search) <- spnames
  search_output <- map_dfr(.x = search, ~ data.frame(.x), .id = 'query') %>%
    janitor::clean_names() %>%
    select(!(c(url, taxon_rank_id, citation, lsid, modified)))
  return(search_output)
}
```

# WoRMS

We've already done TOL ID's in the last script, so we'll go straight to worms
```{r worrms!}
# check which ones are in the database
#then replace resolved
fish_search <- midori_fish %>%
  select(c(query)) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", query)) %>%
  distinct()


# 2: worms
fish_worms <- get_wormsid_(sci_com = fish_search$worms_query, marine_only = FALSE,
                           accepted = FALSE)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
fish_worms2 <- fish_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')


# this cleaning step is relatively temporary until they fix the curl issue
fish_worms2 <- fish_worms2 %>%
  #rename(taxa = scientificname) %>%
  left_join(fish_search, by = c('query' = 'worms_query')) %>%
  select(!(query)) %>%
  rename(taxa = query.y)

# now match species to sciname to remove extra rows
fish_worms2 <- fish_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()


# extract higher and info about freshwater
fish_records <- search_records_worms(fish_worms2$worms_sciname)

# refine results to be useful
fish_records <- fish_records %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

```

```{r}
# temp split, keep getting connection errors in the middle, and its a long run

fish_search1a <- fish_search[1:7000,]
fish_search1b <- fish_search[7001:11000,]
fish_search1c <- fish_search[11001:16000,]
fish_search1d <- fish_search[16001:20687,]


fish_bold2 <- readRDS('fish_bold_temp.rds')
fish_gbifid2 <- readRDS('fish_gbif_temp.rds')
fish_records <- readRDS('fish_worms_temp.rds')


```


```{r}
#3: gbif+bold ids
# now we'll search bold
fish_bold <- get_boldid_(sci = fish_search1d$query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
fish_bold2 <- map_dfr(.x= fish_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))


#fish_bold1a <- fish_bold2
#fish_bold1b <- fish_bold2
#fish_bold1c <- fish_bold2
fish_bold1d <- fish_bold2

fish_bold2 <- fish_bold1a %>%
  bind_rows(fish_bold1b, fish_bold1c, fish_bold1d)

#write to be safe
#saveRDS(fish_bold2, 'fish_bold_temp.rds')


# GBIF id
fish_gbifid <- get_gbifid_(sci = fish_search1d$query, rows = 1)

fish_gbifid2 <- map_dfr(.x= fish_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


#fish_gbif1a <- fish_gbifid2
#fish_gbif1b <- fish_gbifid2
fish_gbif1c <- fish_gbifid2
fish_gbif1d <- fish_gbifid2

fish_gbifid2 <- fish_gbif1a %>%
  bind_rows(fish_gbif1b, fish_gbif1c, fish_gbif1d)

saveRDS(fish_gbifid2, 'fish_gbif_temp.rds')
saveRDS(fish_records, 'fish_worms_temp.rds')



fish_bold2 <- fish_bold2 %>%
  rename(query = taxa_query)
fish_gbifid2 <- fish_gbifid2 %>%
  rename(query = taxa_query)

#4: merge all and find problems
# join all updated fields
fish2 <- midori_fish %>%
  select(species_verbatim, query, ottid_species) %>% 
  rename(ott_id = ottid_species) %>%
  left_join(fish_search) %>%
  left_join(fish_records) %>%
  left_join(fish_bold2) %>%
  left_join(fish_gbifid2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, query)) %>%
  relocate(c('found_taxa', 'rank'), .before = 'query') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('status', 'unacceptreason', 'valid_authority'), .before = 'worms_aphiaid') %>%
  relocate(c('phylum', 'class', 'order', 'family', 'genus',), .before = 'status') %>%
  select(!(c(worms_query, worms_match, original_aphiaid, kingdom))) %>%
  rename(taxa_query = query) %>%
  distinct()

#write full
write.csv(fish2, here(rosetta, 'taxize', '20220727_mifish_taxonomy-full.csv'))


```




# Problems

```{r}
fish_search2 <- fish_search %>%
  filter(!(query %in% fish_records$query))

# we'll deal with these guys later
hybrids <- fish_search2 %>%
  filter(grepl(' x ', query) | grepl(' X', query))

# get all possible searches at once
fish_search3 <- fish_search2 %>%
  filter(!(query %in% hybrids$query)) %>%
  select(query) %>%
  mutate(query_verbatim = query) %>%
  # a few random strings are still here??
  mutate(query = str_remove_all(query, ' sp\\.')) %>%
  mutate(query = str_remove_all(query, ' gr\\.')) %>%
  mutate(query = str_replace_all(query, c('natural gynogenetic Carassius auratus red var\\.' = 'Carassius auratus'))) %>%
  mutate(query = trimws(query)) %>%
  mutate(worms_query = gsub(" ", "+", query)) %>%
  separate(query, into = 'genus_split', " ", 1, 
           remove = FALSE, extra = 'drop')


fish_worms3 <- get_wormsid_(fish_search3$worms_query, marine_only = FALSE,
                            accepted = FALSE)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
fish_worms2 <- fish_worms3%>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'worms_query')

# this cleaning step is relatively temporary until they fix the curl issue
fish_worms2 <- fish_worms2 %>%
  left_join(fish_search3#, by = c('query' = 'worms_query')
            )# %>%
  relocate(found_taxa)# %>%
  select(!(query))

# now match species to sciname to remove extra rows
fish_worms2 <- fish_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(query, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
    filter(!(str_detect(query, " [a-z]* ") == FALSE & 
               str_detect(scientificname, " [a-z]* ") == TRUE)) %>%
  #filter(!(!(found_taxa == scientificname))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# there's only a few of these so lets merge them with generic level searches
genera <- fish_search3 %>%
  select(genus_split) %>%
  distinct()
fish_worms_gen <- get_wormsid_(genera$genus_split, 
                               marine_only = FALSE,
                               accepted = FALSE)



fish_worms_gen2 <- fish_worms_gen %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'genus_split')

# this cleaning step is relatively temporary until they fix the curl issue
fish_worms_gen2 <- fish_worms_gen2 %>%
  left_join(fish_search3)

# now match species to sciname to remove extra rows
fish_worms_gen2 <- fish_worms_gen2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(scientificname, " ") == TRUE)) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

fish_worms_gen_search <- fish_worms_gen2 %>%
  select(genus_split) %>%
  distinct() %>%
  rename(worms_sciname = genus_split) %>%
  bind_rows(fish_worms2) %>%
  select(worms_sciname) %>%
  distinct()

# now use my loop to pull anything found
fish_records_gen <- search_records_worms(fish_worms_gen2$worms_sciname)

# generate terrestrial-only and freshwater-only columns
fish_records_gen <- fish_records_gen %>%
  filter(kingdom == 'Animalia') %>%
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>% 
# rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

```

