---
title: "COI_hakai_taxize"
author: "Kate Sheridan"
date: '2022-06-24'
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(stringr)
library(taxize)
library(fuzzyjoin)
library(here)

# here filepaths
hakai_blast <- here('species_lists', 'hakai', '2021_blast-db')
rosetta <- here('species_lists', 'hakai', '2022rosetta')
```

```{r load-in}
# load in most recent hakai db
hakai_db <- read.csv(here(hakai_blast, 
                              '20210812_hakai_bold_gbif_database_clean.csv'))[,-1] %>%
  janitor::clean_names() %>%
  select(!(verbatim_taxon_rank))
```


## Taxize by group

First I will split the whole database into manageable subsets for taxize. This way I can go into depth with each subset and create lists of exceptions, and if the taxonomy of a single group changes only that group needs to be rerun, not the entire dataset.

The pipeline for all groups is:
1: Worms for higher taxonomy
2: BOLD
3: fetching gbif ids
4 fetching OTL ids
5: list of not-found

```{r make-groups}
# remove 'sp.'
hakai_db <- hakai_db %>%
  mutate(species = str_replace_all(species, c(" sp\\." = "")))

# extract relevant columns
## note 'species' column includes entries from all taxonomic levels
hakai_db_subset <- hakai_db %>%
  select(species, phylum, class, family) %>%
  filter(!(is.na(species) | species == "")) %>%
  distinct() %>%
  rename(taxa = species)

annelid <- hakai_db_subset %>%
  subset(phylum == 'Annelida')

# edit later
arthropod <- bold_gb_hakai %>%
  subset(Phylum == 'Arthropoda')

mollusc <- bold_gb_hakai %>%
  subset(Phylum == 'Mollusca')

chordata <- bold_gb_hakai %>%
  subset(Phylum == 'Chordata')

# three 'larger' phyla
ech_platy_nem <- bold_gb_hakai %>%
  subset(Phylum %in% c('Echinodermata', 'Platyhelminthes', 'Nematoda'))

#all the small phyla
small_phyla <- bold_gb_hakai %>%
  subset(!(Phylum %in% c('Annelida', 'Arthropoda', 'Mollusca', 'Chordata',
                         'Echinodermata', 'Platyhelminthes', 'Nematoda')))


```


### Annelids

```{r annelids}
# 1: worms
# first get resolved names from tol
annelid_resolved <- tol_resolve(annelid$taxa, context_name = 'Animals') %>%
  mutate(search_string = str_to_sentence(search_string))

# format for merge
annelid_tol2 <- annelid_resolved %>%
  select(!(c(approximate_match, number_matches))) %>%
  # for not found list
  filter(!(is.na(unique_name))) %>%
  rename(taxa = search_string,
         tol_sciname = unique_name)


#then replace resolved
annelid_search <- annelid %>%
  left_join(annelid_resolved, by = c('taxa' = 'search_string')) %>%
  select(c(taxa, unique_name, phylum, class, family)) %>%
  #include replacements from tol and any overhanging taxa
  mutate(taxa_query = coalesce(unique_name, taxa)) %>%
  relocate(taxa_query) %>%
  #remove any known introduction from tol
  mutate(taxa_query = str_replace_all(taxa, ' \\(species in Opisthokonta\\)', "")) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", taxa_query)) %>%
  select(!(c(unique_name)))


annelid_worms <- get_wormsid_(sci_com = annelid_search$worms_query)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
annelid_worms2 <- annelid_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
annelid_worms2 <- annelid_worms2 %>%
  left_join(annelid_search, by = c('query' = 'worms_query')) %>%
  relocate(taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
annelid_worms2 <- annelid_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# worms classification
annelid_worms_classify <- classification(annelid_worms2$worms_aphiaid, db = 'worms')

# make and rotate dataframe 
annelid_worms_classify2 <- map_dfr(.x = annelid_worms_classify, ~ data.frame(.x), .id = 'worms_aphiaid') %>%
  pivot_wider(id_cols = worms_aphiaid, names_from = rank, values_from = c(name, id)) %>%
  rename_with(~ str_replace(.x, 'name_', '')) %>%
  rename_with(~ str_replace(.x, 'id_', 'wormsid_')) %>%
  mutate(worms_aphiaid = as.numeric(worms_aphiaid)) %>%
  janitor::clean_names()

annelid_worms3 <- annelid_worms2 %>%
  left_join(annelid_worms_classify2) %>%
  filter(kingdom == 'Animalia') %>%
  janitor::remove_empty() %>%
  #select only desired taxonomic levels and their IDs
  ## note subgenus was empty here but it probably shouldn't be
  select(c(taxa_query, taxa, worms_aphiaid, worms_sciname,
           phylum, class, subclass, order, family, genus, #subgenus, 
           species,
           wormsid_phylum, wormsid_class, wormsid_subclass, wormsid_order,
           wormsid_family, wormsid_genus, #wormsid_subgenus, 
           wormsid_species,
           authority))


# now we'll search bold
annelid_bold <- get_boldid_(sci = annelid_search$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
annelid_bold2 <- map_dfr(.x= annelid_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
annelid_gbifid <- get_gbifid_(sci = annelid_search$taxa_query, rows = 1)

annelid_gbifid2 <- map_dfr(.x= annelid_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)






# join all updated fields
annelid2 <- annelid_search %>%
  #select(species) %>%
  #rename(query = species) %>%
  left_join(annelid_worms3) %>%
  left_join(annelid_bold2) %>%
  left_join(annelid_gbifid2) %>%
  left_join(annelid_tol2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  relocate('rank', .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  select(!(worms_query))

#write full
write.csv(annelid2, here(rosetta, 'taxize', '20220624_annelid_taxonomy-full.csv'))

# not-found list
annelid_notfound <- hakai_db %>%
  filter(phylum == 'Annelida') %>%
  select(species, phylum, class, family) %>%
  distinct() %>%
  filter(!(is.na(species) | species == "")) %>%
  #not in gbif or obis or worms
  filter(!(species %in% annelid_gbifid2$query |
           species %in% annelid_bold2$query | 
           species %in% annelid_worms3$query |
           species %in% annelid_tol2$query))

# for instances where the TOL resolve wasn't actually worms-ok
annelid_nf_worms <- annelid2 %>%
  filter(is.na(worms_aphiaid) == TRUE & is.na(ott_id) == FALSE)

#write out not-found
write.csv(annelid_notfound, here(rosetta, 'problems', '20220624_annelid_-not-found.csv'))

###### old stuff under this line

annelid_resolved <- tol_resolve(annelid$species, context_name = 'Animals')

#remove any unique names with parentheses
annelid_resolved <- annelid_resolved %>%
  mutate(unique_name = str_replace_all(unique_name, c(" [\\(][a-zA-Z]+[\\)]" = "")))

# how many synonyms
table(annelid_resolved$is_synonym)
annelid_resolved %>% pull(unique_name)

# join resolved with original
# stringdist join lets us be off by one character: the capital letter
# Note; search_string is necessary for the merge
annelid <- annelid %>%
  stringdist_left_join(., annelid_resolved %>%
                         select(unique_name, ott_id, 
                                is_synonym, flags, search_string),
                  by = c('Species' = 'search_string'),
                  max_dist = 1)

# clean dataframe
# fill with NAs, turn taxize ID into species, preserve original species
# and remove useless search_string column, and X if it shows up
annelid <- annelid %>%
  na_if(., "") %>%
  rename(Species = unique_name,
         previousIdentifications = Species) %>%
  select(-c(search_string))

#re-pull annelid_sp
annelid_sp <- annelid %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

## Now we'll add more useful columns by getting gbifIDs 
# and repopulating higher taxonomy so the whole dataset is clean

#re-get gbifids with get_gbifid_ to get all options
annelid_gbifid <- get_gbifid_(sci = annelid_sp,
                             rows = NA
                             )

#bind results
annelid_gbifid_df2 <- dplyr::bind_rows(annelid_gbifid, .id = "query")
rownames(annelid_gbifid_df2) <- NULL

#separate out exact + found
gbifid_found <- annelid_gbifid_df2 %>%
  filter(status == 'ACCEPTED' & matchtype == 'EXACT') %>%
  select(!(c(confidence, synonym, note, acceptedusagekey,
             canonicalname)))

# update to only be things not found to be exact/accepted
# and with decent confidence
annelid_gbifid_df2 <- annelid_gbifid_df2 %>%
  subset(!(query %in% gbifid_found$query)) %>%
  subset(confidence > 80)


#data table merges must set as.data.table or the syntax doesn't work
annelid <- as.data.table(annelid)
gbifid_found <- as.data.table(gbifid_found)

#Using data.table package to merge 
#will find a dplyr method eventually...
annelid2 <- gbifid_found[annelid, 
                         on = c(query = 'Species')][!(is.na(phylum)), Phylum := phylum][!(is.na(class)), Class := class][!(is.na(order)), Order := order][!(is.na(family)), Family := family][!(is.na(genus)), Genus := genus]


#back to annelid
annelid <- annelid2 %>%
  select(!(c(status, matchtype, kingdom, phylum,
             order, class, family, genus, species))) %>%
  rename(scientificNameID = scientificname,
         Species = query)

# Save group
write.csv(annelid, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_annelids.csv'))




# collect problems
notin_tol <- annelid_resolved %>%
  filter(is.na(unique_name)) %>%
  select(search_string)

gbif_issue <- annelid_gbifid_df2 %>%
  select(query) %>%
  distinct(query)

notin_gbif <- annelid_sp %>%
  enframe() %>%
  subset(!(value %in% annelid_gbifid_df2$query)) %>%
  subset(!(value %in% gbifid_found$query))

annelid_problem <- c(notin_tol$search_string, notin_gbif$value, gbif_issue$query)

# Save problems
write.csv(annelid_problem, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_annelids-p.csv'))

write.csv(annelid_gbifid_df2, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_annelids-gbif_issue.csv'))



annelid_problem
```




### Arthropods


```{r}
#remove NAs and make list of only unique species
arthropod_sp <- arthropod %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

arthropod_resolved <- tol_resolve(arthropod_sp, context_name = 'Animals')

#remove any unique names with parentheses
arthropod_resolved <- arthropod_resolved %>%
  mutate(unique_name = str_replace_all(unique_name, c(" [\\(][a-zA-Z]+[\\)]" = "")))

# how many synonyms
table(arthropod_resolved$is_synonym)
arthropod_resolved %>% pull(unique_name)

# join resolved with original
# stringdist join lets us be off by one character: the capital letter
# Note; search_string is necessary for the merge
arthropod <- arthropod %>%
  stringdist_left_join(., arthropod_resolved %>%
                         select(unique_name, ott_id, 
                                is_synonym, flags, search_string),
                  by = c('Species' = 'search_string'),
                  max_dist = 1)

# clean dataframe
# fill with NAs, turn taxize ID into species, preserve original species
# and remove useless search_string column, and X if it shows up
arthropod <- arthropod %>%
  na_if(., "") %>%
  rename(Species = unique_name,
         previousIdentifications = Species) %>%
  select(-c(search_string))

#re-pull arthropod_sp
arthropod_sp <- arthropod %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

## Now we'll add more useful columns by getting gbifIDs 
# and repopulating higher taxonomy so the whole dataset is clean

#re-get gbifids with get_gbifid_ to get all options
arthropod_gbifid <- get_gbifid_(sci = arthropod_sp,
                             rows = NA
                             )

#bind results
arthropod_gbifid_df2 <- dplyr::bind_rows(arthropod_gbifid, .id = "query")
rownames(arthropod_gbifid_df2) <- NULL

#separate out exact + found
gbifid_found <- arthropod_gbifid_df2 %>%
  filter(status == 'ACCEPTED' & matchtype == 'EXACT') %>%
  select(!(c(confidence, synonym, note, acceptedusagekey,
             canonicalname)))


arthropod_gbifid_df2 <- arthropod_gbifid_df2 %>%
  subset(!(query %in% gbifid_found$query)) %>%
  subset(confidence > 80)


#data table merges must set as.data.table or the syntax doesn't work
arthropod <- as.data.table(arthropod)
gbifid_found <- as.data.table(gbifid_found)

#Using data.table package to merge 
#will find a dplyr method eventually...
arthropod2 <- gbifid_found[arthropod, 
                         on = c(query = 'Species')][!(is.na(phylum)), Phylum := phylum][!(is.na(class)), Class := class][!(is.na(order)), Order := order][!(is.na(family)), Family := family][!(is.na(genus)), Genus := genus]


#back to arthropod
arthropod <- arthropod2 %>%
  select(!(c(status, matchtype, kingdom, phylum,
             order, class, family, genus, species))) %>%
  rename(scientificNameID = scientificname,
         Species = query)

# Save group
write.csv(arthropod, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_arthropod.csv'))




# collect problems
notin_tol <- arthropod_resolved %>%
  filter(is.na(unique_name)) %>%
  select(search_string)

gbif_issue <- arthropod_gbifid_df2 %>%
  select(query) %>%
  distinct(query)

notin_gbif <- arthropod_sp %>%
  enframe() %>%
  subset(!(value %in% arthropod_gbifid_df2$query)) %>%
  subset(!(value %in% gbifid_found$query))

arthropod_problem <- c(notin_tol$search_string, notin_gbif$value, gbif_issue$query)

# Save problems
write.csv(arthropod_problem, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_arthropod-p.csv'))

write.csv(arthropod_gbifid_df2, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_arthropod-gbif_issue.csv'))
```



### Chordates

```{r}
#remove NAs and make list of only unique species
chordata_sp <- chordata %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

chordata_resolved <- tol_resolve(chordata_sp, context_name = 'Animals')

#remove any unique names with parentheses
chordata_resolved <- chordata_resolved %>%
  mutate(unique_name = str_replace_all(unique_name, c(" [\\(][a-zA-Z]+[\\)]" = "")))

# how many synonyms
table(chordata_resolved$is_synonym)
#chordata_resolved %>% pull(unique_name)

# join resolved with original
# stringdist join lets us be off by one character: the capital letter
# Note; search_string is necessary for the merge
chordata <- chordata %>%
  stringdist_left_join(., chordata_resolved %>%
                         select(unique_name, ott_id, 
                                is_synonym, flags, search_string),
                  by = c('Species' = 'search_string'),
                  max_dist = 1)

# clean dataframe
# fill with NAs, turn taxize ID into species, preserve original species
# and remove useless search_string column, and X if it shows up
chordata <- chordata %>%
  na_if(., "") %>%
  rename(Species = unique_name,
         previousIdentifications = Species) %>%
  select(-c(search_string))

#re-pull sp list
chordata_sp <- chordata %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()



###### insert gbifid stuff

# BRUTE FORCE / slow
chordata_gbifid <- get_gbifid(sci = chordata_sp,
                             #do not run interactively (yet)
                             ask = FALSE,
                             phylum = "Chordata"
                             )

chordata_gbifid_df <- chordata_gbifid %>% 
  as.data.frame(.) %>%
  #add in species info
  mutate(Species = chordata_sp)

# put gbifids into dataframe
chordata <- chordata %>%
  left_join(., chordata_gbifid_df %>%
              subset(match == 'found') %>%
                         select(ids, Species))

#re-pull chordata_sp
chordata_sp <- chordata_gbifid_df %>%
  subset(!(match == "found")) %>%
  pull(Species) %>%
  unique()

# rerun gbifid interactively so that it will ask which one to take
# update to be get_gbifid_() in the future
chordata_gbifid <- get_gbifid(sci = chordata_sp,
                             #run interactively
                             ask = TRUE,
                             phylum = "Annelida"
                             )

chordata_gbifid_df <- chordata_gbifid %>% 
  as.data.frame(.) %>%
  mutate(Species = chordata_sp)

# put more gbifids into dataframe
chordata <- chordata %>%
  left_join(., chordata_gbifid_df %>%
              subset(match == 'found') %>%
                         select(ids, Species))


# Save group
write.csv(chordata, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_chordata.csv'))




# collect problems
notin_tol <- chordata_resolved %>%
  filter(is.na(unique_name)) %>%
  select(search_string)

notin_gbif <- chordata_gbifid_df %>%
  subset(match == "not found") %>%
  select(Species)

chordata_problem <- c(notin_tol$search_string, notin_gbif$species)




write.csv(arthropod_problem, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_chordata-p.csv'))
```


```{r}
#remove NAs and make list of only unique species
chordata_sp <- chordata %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

chordata_resolved <- tol_resolve(chordata_sp, context_name = 'Animals')

#remove any unique names with parentheses
chordata_resolved <- chordata_resolved %>%
  mutate(unique_name = str_replace_all(unique_name, c(" [\\(][a-zA-Z]+[\\)]" = "")))

# how many synonyms
table(chordata_resolved$is_synonym)
chordata_resolved %>% pull(unique_name)

# join resolved with original
# stringdist join lets us be off by one character: the capital letter
# Note; search_string is necessary for the merge
chordata <- chordata %>%
  stringdist_left_join(., chordata_resolved %>%
                         select(unique_name, ott_id, 
                                is_synonym, flags, search_string),
                  by = c('Species' = 'search_string'),
                  max_dist = 1)

# clean dataframe
# fill with NAs, turn taxize ID into species, preserve original species
# and remove useless search_string column, and X if it shows up
chordata <- chordata %>%
  na_if(., "") %>%
  rename(Species = unique_name,
         previousIdentifications = Species) %>%
  select(-c(search_string))

#re-pull chordata_sp
chordata_sp <- chordata %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

## Now we'll add more useful columns by getting gbifIDs 
# and repopulating higher taxonomy so the whole dataset is clean

#re-get gbifids with get_gbifid_ to get all options
chordata_gbifid <- get_gbifid_(sci = chordata_sp,
                             rows = NA
                             )

#bind results
chordata_gbifid_df2 <- dplyr::bind_rows(chordata_gbifid, .id = "query")
rownames(chordata_gbifid_df2) <- NULL

#separate out exact + found
gbifid_found <- chordata_gbifid_df2 %>%
  filter(status == 'ACCEPTED' & matchtype == 'EXACT') %>%
  select(!(c(confidence, synonym, note, acceptedusagekey,
             canonicalname)))


chordata_gbifid_df2 <- chordata_gbifid_df2 %>%
  subset(!(query %in% gbifid_found$query)) %>%
  subset(confidence > 80)


#data table merges must set as.data.table or the syntax doesn't work
chordata <- as.data.table(chordata)
gbifid_found <- as.data.table(gbifid_found)

#Using data.table package to merge 
#will find a dplyr method eventually...
chordata2 <- gbifid_found[chordata, 
                         on = c(query = 'Species')][!(is.na(phylum)), Phylum := phylum][!(is.na(class)), Class := class][!(is.na(order)), Order := order][!(is.na(family)), Family := family][!(is.na(genus)), Genus := genus]


#back to chordata
chordata <- chordata2 %>%
  select(!(c(status, matchtype, kingdom, phylum,
             order, class, family, genus, species))) %>%
  rename(scientificNameID = scientificname,
         Species = query)

# Save group
write.csv(chordata, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_chordata.csv'))




# collect problems
notin_tol <- chordata_resolved %>%
  filter(is.na(unique_name)) %>%
  select(search_string)

gbif_issue <- chordata_gbifid_df2 %>%
  select(query) %>%
  distinct(query)

notin_gbif <- chordata_sp %>%
  enframe() %>%
  subset(!(value %in% chordata_gbifid_df2$query)) %>%
  subset(!(value %in% gbifid_found$query))

chordata_problem <- c(notin_tol$search_string, notin_gbif$value, gbif_issue$query)

# Save problems
write.csv(chordata_problem, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_chordata-p.csv'))

write.csv(chordata_gbifid_df2, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_chordata-gbif_issue.csv'))
```



### Molluscs


```{r}
#remove NAs and make list of only unique species
mollusc_sp <- mollusc %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

mollusc_resolved <- tol_resolve(mollusc_sp, context_name = 'Animals')

#remove any unique names with parentheses
mollusc_resolved <- mollusc_resolved %>%
  mutate(unique_name = str_replace_all(unique_name, c(" [\\(][a-zA-Z]+[\\)]" = "")))

# how many synonyms
table(mollusc_resolved$is_synonym)
mollusc_resolved %>% pull(unique_name)

# join resolved with original
# stringdist join lets us be off by one character: the capital letter
# Note; search_string is necessary for the merge
mollusc <- mollusc %>%
  stringdist_left_join(., mollusc_resolved %>%
                         select(unique_name, ott_id, 
                                is_synonym, flags, search_string),
                  by = c('Species' = 'search_string'),
                  max_dist = 1)

# clean dataframe
# fill with NAs, turn taxize ID into species, preserve original species
# and remove useless search_string column, and X if it shows up
mollusc <- mollusc %>%
  na_if(., "") %>%
  rename(Species = unique_name,
         previousIdentifications = Species) %>%
  select(-c(search_string))

#re-pull mollusc_sp
mollusc_sp <- mollusc %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

## Now we'll add more useful columns by getting gbifIDs 
# and repopulating higher taxonomy so the whole dataset is clean

#re-get gbifids with get_gbifid_ to get all options
mollusc_gbifid <- get_gbifid_(sci = mollusc_sp,
                             rows = NA
                             )

#bind results
mollusc_gbifid_df2 <- dplyr::bind_rows(mollusc_gbifid, .id = "query")
rownames(mollusc_gbifid_df2) <- NULL

#separate out exact + found
gbifid_found <- mollusc_gbifid_df2 %>%
  filter(status == 'ACCEPTED' & matchtype == 'EXACT') %>%
  select(!(c(confidence, synonym, note, acceptedusagekey,
             canonicalname)))


mollusc_gbifid_df2 <- mollusc_gbifid_df2 %>%
  subset(!(query %in% gbifid_found$query)) %>%
  subset(confidence > 80)


#data table merges must set as.data.table or the syntax doesn't work
mollusc <- as.data.table(mollusc)
gbifid_found <- as.data.table(gbifid_found)

#Using data.table package to merge 
#will find a dplyr method eventually...
mollusc2 <- gbifid_found[mollusc, 
                         on = c(query = 'Species')][!(is.na(phylum)), Phylum := phylum][!(is.na(class)), Class := class][!(is.na(order)), Order := order][!(is.na(family)), Family := family][!(is.na(genus)), Genus := genus]


#back to mollusc
mollusc <- mollusc2 %>%
  select(!(c(status, matchtype, kingdom, phylum,
             order, class, family, genus, species))) %>%
  rename(scientificNameID = scientificname,
         Species = query)

# Save group
write.csv(mollusc, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_mollusc.csv'))




# collect problems
notin_tol <- mollusc_resolved %>%
  filter(is.na(unique_name)) %>%
  select(search_string)

gbif_issue <- mollusc_gbifid_df2 %>%
  select(query) %>%
  distinct(query)

notin_gbif <- mollusc_sp %>%
  enframe() %>%
  subset(!(value %in% mollusc_gbifid_df2$query)) %>%
  subset(!(value %in% gbifid_found$query))

mollusc_problem <- c(notin_tol$search_string, notin_gbif$value, gbif_issue$query)

# Save problems
write.csv(mollusc_problem, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_mollusc-p.csv'))

write.csv(mollusc_gbifid_df2, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_mollusc-gbif_issue.csv'))
```


### Echinoderms, Platyhelminthes, Nemerteans

These groups are done together since they are each moderate in size.


```{r}
#remove NAs and make list of only unique species
ech_platy_nem_sp <- ech_platy_nem %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

ech_platy_nem_resolved <- tol_resolve(ech_platy_nem_sp, context_name = 'Animals')

#remove any unique names with parentheses
ech_platy_nem_resolved <- ech_platy_nem_resolved %>%
  mutate(unique_name = str_replace_all(unique_name, c(" [\\(][a-zA-Z]+[\\)]" = "")))

# how many synonyms
table(ech_platy_nem_resolved$is_synonym)
ech_platy_nem_resolved %>% pull(unique_name)

# join resolved with original
# stringdist join lets us be off by one character: the capital letter
# Note; search_string is necessary for the merge
ech_platy_nem <- ech_platy_nem %>%
  stringdist_left_join(., ech_platy_nem_resolved %>%
                         select(unique_name, ott_id, 
                                is_synonym, flags, search_string),
                  by = c('Species' = 'search_string'),
                  max_dist = 1)

# clean dataframe
# fill with NAs, turn taxize ID into species, preserve original species
# and remove useless search_string column, and X if it shows up
ech_platy_nem <- ech_platy_nem %>%
  na_if(., "") %>%
  rename(Species = unique_name,
         previousIdentifications = Species) %>%
  select(-c(search_string))

#re-pull ech_platy_nem_sp
ech_platy_nem_sp <- ech_platy_nem %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

## Now we'll add more useful columns by getting gbifIDs 
# and repopulating higher taxonomy so the whole dataset is clean

#re-get gbifids with get_gbifid_ to get all options
ech_platy_nem_gbifid <- get_gbifid_(sci = ech_platy_nem_sp,
                             rows = NA
                             )

#bind results
ech_platy_nem_gbifid_df2 <- dplyr::bind_rows(ech_platy_nem_gbifid, .id = "query")
rownames(ech_platy_nem_gbifid_df2) <- NULL

#separate out exact + found
gbifid_found <- ech_platy_nem_gbifid_df2 %>%
  filter(status == 'ACCEPTED' & matchtype == 'EXACT') %>%
  select(!(c(confidence, synonym, note, acceptedusagekey,
             canonicalname)))


ech_platy_nem_gbifid_df2 <- ech_platy_nem_gbifid_df2 %>%
  subset(!(query %in% gbifid_found$query)) %>%
  subset(confidence > 80)


#data table merges must set as.data.table or the syntax doesn't work
ech_platy_nem <- as.data.table(ech_platy_nem)
gbifid_found <- as.data.table(gbifid_found)

#Using data.table package to merge 
#will find a dplyr method eventually...
ech_platy_nem2 <- gbifid_found[ech_platy_nem, 
                         on = c(query = 'Species')][!(is.na(phylum)), Phylum := phylum][!(is.na(class)), Class := class][!(is.na(order)), Order := order][!(is.na(family)), Family := family][!(is.na(genus)), Genus := genus]


#back to ech_platy_nem
ech_platy_nem <- ech_platy_nem2 %>%
  select(!(c(status, matchtype, kingdom, phylum,
             order, class, family, genus, species))) %>%
  rename(scientificNameID = scientificname,
         Species = query)

# Save group
write.csv(ech_platy_nem, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_ech_platy_nem.csv'))




# collect problems
notin_tol <- ech_platy_nem_resolved %>%
  filter(is.na(unique_name)) %>%
  select(search_string)

gbif_issue <- ech_platy_nem_gbifid_df2 %>%
  select(query) %>%
  distinct(query)

notin_gbif <- ech_platy_nem_sp %>%
  enframe() %>%
  subset(!(value %in% ech_platy_nem_gbifid_df2$query)) %>%
  subset(!(value %in% gbifid_found$query))

ech_platy_nem_problem <- c(notin_tol$search_string, notin_gbif$value, gbif_issue$query)

# Save problems
write.csv(ech_platy_nem_problem, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_ech_platy_nem-p.csv'))

write.csv(ech_platy_nem_gbifid_df2, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_ech_platy_nem-gbif_issue.csv'))
```



### Small Phyla

Last but not least, everything else

```{r}
#remove NAs and make list of only unique species
small_phyla_sp <- small_phyla %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

small_phyla_resolved <- tol_resolve(small_phyla_sp, context_name = 'Animals')

#remove any unique names with parentheses
small_phyla_resolved <- small_phyla_resolved %>%
  mutate(unique_name = str_replace_all(unique_name, c(" [\\(][a-zA-Z]+[\\)]" = "")))

# how many synonyms
table(small_phyla_resolved$is_synonym)
small_phyla_resolved %>% pull(unique_name)

# join resolved with original
# stringdist join lets us be off by one character: the capital letter
# Note; search_string is necessary for the merge
small_phyla <- small_phyla %>%
  stringdist_left_join(., small_phyla_resolved %>%
                         select(unique_name, ott_id, 
                                is_synonym, flags, search_string),
                  by = c('Species' = 'search_string'),
                  max_dist = 1)

# clean dataframe
# fill with NAs, turn taxize ID into species, preserve original species
# and remove useless search_string column, and X if it shows up
small_phyla <- small_phyla %>%
  na_if(., "") %>%
  rename(Species = unique_name,
         previousIdentifications = Species) %>%
  select(-c(search_string))

#re-pull small_phyla_sp
small_phyla_sp <- small_phyla %>%
  subset(!(Species == "")) %>%
  pull(Species) %>%
  unique()

## Now we'll add more useful columns by getting gbifIDs 
# and repopulating higher taxonomy so the whole dataset is clean

#re-get gbifids with get_gbifid_ to get all options
small_phyla_gbifid <- get_gbifid_(sci = small_phyla_sp,
                             rows = NA
                             )

#bind results
small_phyla_gbifid_df2 <- dplyr::bind_rows(small_phyla_gbifid, .id = "query")
rownames(small_phyla_gbifid_df2) <- NULL

#separate out exact + found
gbifid_found <- small_phyla_gbifid_df2 %>%
  filter(status == 'ACCEPTED' & matchtype == 'EXACT') %>%
  select(!(c(confidence, synonym, note, acceptedusagekey,
             canonicalname)))


small_phyla_gbifid_df2 <- small_phyla_gbifid_df2 %>%
  subset(!(query %in% gbifid_found$query)) %>%
  subset(confidence > 80)


#data table merges must set as.data.table or the syntax doesn't work
small_phyla <- as.data.table(small_phyla)
gbifid_found <- as.data.table(gbifid_found)

#Using data.table package to merge 
#will find a dplyr method eventually...
small_phyla2 <- gbifid_found[small_phyla, 
                         on = c(query = 'Species')][!(is.na(phylum)), Phylum := phylum][!(is.na(class)), Class := class][!(is.na(order)), Order := order][!(is.na(family)), Family := family][!(is.na(genus)), Genus := genus]


#back to small_phyla
small_phyla <- small_phyla2 %>%
  select(!(c(status, matchtype, kingdom, phylum,
             order, class, family, genus, species))) %>%
  rename(scientificNameID = scientificname,
         Species = query)

# Save group
write.csv(small_phyla, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_small_phyla.csv'))




## collect problems
notin_tol <- small_phyla_resolved %>%
  filter(is.na(unique_name)) %>%
  select(search_string)

gbif_issue <- small_phyla_gbifid_df2 %>%
  select(query) %>%
  distinct(query)

notin_gbif <- small_phyla_sp %>%
  enframe() %>%
  subset(!(value %in% small_phyla_gbifid_df2$query)) %>%
  subset(!(value %in% gbifid_found$query))

small_phyla_problem <- c(notin_tol$search_string, notin_gbif$value, gbif_issue$query)

# Save problems
write.csv(small_phyla_problem, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_small_phyla-p.csv'))

write.csv(small_phyla_gbifid_df2, here('hakaidata', '2021rosetta', 'problems', 
                              '20210812_small_phyla-gbif_issue.csv'))
```



## Merge generated files

```{r}
# merge files
#this method seems slow so maybe turn into a dplyr join or whatever
rosetta <- merge(merge(merge(merge(merge(annelid, 
                                   arthropod, all = TRUE), 
                 chordata, all = TRUE),
                 mollusc, all = TRUE),
                 ech_platy_nem, all = TRUE),
                 small_phyla, all = TRUE)

# rename columns
#note that as of right now species column is the full epithet rather than 
# just the specific epithet as darwincore would like. 
# at a later date I will add a line to make the specific epithet then 
#turn "species" this into an ID column or something
rosetta <- rosetta %>%
  select(BIN, Process.ID, Catalog.Num, ott_id,
         Domain, Kingdom, Phylum, Class, Order, Family, Genus, Species, 
         verbatimTaxonRank, previousIdentifications, is_synonym) %>%
  rename(associatedSequences = BIN,
         recordNumber = Process.ID,
         catalogNumber = Catalog.Num,
         domain = Domain,
         kingdom = Kingdom,
         phylum = Phylum,
         class = Class,
         order = Order,
         family = Family,
         genus = Genus,
         species = Species) %>%
  na_if(., "")

# save
write_csv(rosetta, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_rosetta.csv'))
```

maybe write a python script for if you only updated one file