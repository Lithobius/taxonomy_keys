---
title: "COI_hakai_taxize"
author: "Kate Sheridan"
date: '2022-06-24'
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(stringr)
library(taxize)
library(here)

# here filepaths
hakai_blast <- here('species_lists', 'hakai', '2021_blast-db')
rosetta <- here('species_lists', 'hakai', '2022rosetta')
```

```{r load-in}
# load in most recent hakai db
hakai_db <- read.csv(here(hakai_blast, 
                              '20220718_hakai_bold_gbif_database_clean.csv'))[,-1]
```

```{r worms-function}
library(worrms)

## requires worrms to be loaded
# input is vector of species names
# use wm_records_names to extract 
# this doesn't need the + signs

# right now this breaks if not-found
search_records_worms <- function(spnames) {
  search <- tibble()
  for (i in spnames) {
    print(paste0('searching for ', i))
    record <- wm_records_names(i, marine_only = FALSE)
    message('done')
    search <- append(search, record)
  }
  names(search) <- spnames
  search_output <- map_dfr(.x = search, ~ data.frame(.x), .id = 'query') %>%
    janitor::clean_names() %>%
    select(!(c(url, taxon_rank_id, citation, lsid, modified)))
  return(search_output)
}
```

## Taxize by group

First I will split the whole database into manageable subsets for taxize. This way I can go into depth with each subset and create lists of exceptions, and if the taxonomy of a single group changes only that group needs to be rerun, not the entire dataset.

The pipeline for all groups is:
1: Worms for higher taxonomy
2: BOLD
3: fetching gbif ids
4 fetching OTL ids
5: list of not-found

```{r make-groups}

# extract relevant columns
## note 'identification' column includes entries from all taxonomic levels
hakai_db_subset <- hakai_db %>%
  select(identification, phylum, class, family) %>%
  distinct() %>%
  rename(taxa = identification)

annelid <- hakai_db_subset %>%
  subset(phylum %in% c('Annelida', 'Sipuncula'))

arthropod <- hakai_db_subset %>%
  subset(phylum == 'Arthropoda')

chordata <- hakai_db_subset %>%
  subset(phylum == 'Chordata')

mollusca <- hakai_db_subset %>%
  subset(phylum == 'Mollusca')

# three 'larger' phyla
ech_platy_nem <- hakai_db_subset %>%
  subset(phylum %in% c('Echinodermata', 'Platyhelminthes', 'Nematoda'))

#all the small phyla
small_phyla <- hakai_db_subset %>%
  subset(!(phylum %in% c('Annelida', 'Arthropoda', 'Mollusca', 'Chordata',
                         'Echinodermata', 'Platyhelminthes', 'Nematoda', 'Sipuncula')))

```


### Annelids

```{r annelids}
# 1: tol_resolve
# first get resolved names from tol
annelid_resolved <- tol_resolve(annelid$taxa, context_name = 'Animals') %>%
  mutate(search_string = str_to_sentence(search_string))

# format for merge
annelid_tol2 <- annelid_resolved %>%
  select(!(c(approximate_match, number_matches))) %>%
  # for not found list
  filter(!(is.na(unique_name))) %>%
  rename(taxa = search_string,
         tol_sciname = unique_name)


#then replace resolved
annelid_search <- annelid %>%
  left_join(annelid_resolved, by = c('taxa' = 'search_string')) %>%
  select(c(taxa, unique_name, phylum, class, family)) %>%
  #include replacements from tol and any overhanging taxa
  mutate(taxa_query = coalesce(unique_name, taxa)) %>%
  relocate(taxa_query) %>%
  #remove any known introduction from tol
  mutate(taxa_query = str_replace_all(taxa, ' \\(species in Opisthokonta\\)', "")) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", taxa_query)) %>%
  select(!(c(unique_name)))

# 2: worms
annelid_worms <- get_wormsid_(sci_com = annelid_search$worms_query)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
annelid_worms2 <- annelid_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
annelid_worms2 <- annelid_worms2 %>%
  left_join(annelid_search, by = c('query' = 'worms_query')) %>%
  relocate(taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
annelid_worms2 <- annelid_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()




# extract higher and info about freshwater
annelid_records <- search_records_worms(annelid_worms2$worms_sciname)

# refine results to be useful
annelid_records <- annelid_records %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))

#3: gbif+bold ids
# now we'll search bold
annelid_bold <- get_boldid_(sci = annelid_search$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
annelid_bold2 <- map_dfr(.x= annelid_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
annelid_gbifid <- get_gbifid_(sci = annelid_search$taxa_query, rows = 1)

annelid_gbifid2 <- map_dfr(.x= annelid_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)


#4: merge all and find problems
# join all updated fields
annelid2 <- annelid_search %>%
  left_join(annelid_records) %>%
  left_join(annelid_bold2) %>%
  left_join(annelid_gbifid2) %>%
  left_join(annelid_tol2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank'), .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_query, worms_match, original_aphiaid, taxa)))

#write full
write.csv(annelid2, here(rosetta, 'taxize', '20220716_annelid_taxonomy-full.csv'))


# not-found list
annelid_notfound <- annelid %>%
  #filter(phylum == 'Annelida') %>%
  #select(species, phylum, class, family) %>%
  #distinct() %>%
  #filter(!(is.na(species) | species == "")) %>%
  #not in gbif or obis or worms
  filter(!(taxa %in% annelid_gbifid2$taxa_query |
           taxa %in% annelid_bold2$taxa_query | 
           taxa %in% annelid_records$taxa_query |
           taxa %in% annelid_tol2$taxa))

#write out not-found
write.csv(annelid_notfound, here(rosetta, 'problems', '20220716_annelid_not-found.csv'))

# for instances where the TOL resolve wasn't actually worms-ok
annelid_nf_worms <- annelid2 %>%
  filter(is.na(worms_aphiaid) == TRUE & is.na(ott_id) == FALSE)

#write out worms issues
write.csv(annelid_nf_worms, here(rosetta, 'problems', '20220716_annelid_worms-tol-conflict.csv'))
```




### Arthropods


```{r}
# in arthropods there are some duplicates in class
arthropod <- arthropod %>%
  select(!(c(class, family))) %>%
  distinct() %>%
  mutate(taxa = as.character(taxa))

# 1: worms
# first get resolved names from tol
arthropod_resolved <- tol_resolve(arthropod$taxa, context_name = 'Animals') %>%
  mutate(search_string = str_to_sentence(search_string))

# format for merge
arthropod_tol2 <- arthropod_resolved %>%
  select(!(c(approximate_match, number_matches))) %>%
  # for not found list
  filter(!(is.na(unique_name))) %>%
  rename(taxa = search_string,
         tol_sciname = unique_name)


#then replace resolved
arthropod_search <- arthropod %>%
  left_join(arthropod_resolved, by = c('taxa' = 'search_string')) %>%
  select(c(taxa, unique_name, phylum)) %>%
  #include replacements from tol and any overhanging taxa
  mutate(taxa_query = coalesce(unique_name, taxa)) %>%
  relocate(taxa_query) %>%
  #remove any known introduction from tol
  mutate(taxa_query = str_replace_all(taxa, ' \\(species in Opisthokonta\\)', "")) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", taxa_query)) %>%
  select(!(c(unique_name)))


arthropod_worms <- get_wormsid_(sci_com = arthropod_search$worms_query)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
arthropod_worms2 <- arthropod_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
arthropod_worms2 <- arthropod_worms2 %>%
  left_join(arthropod_search, by = c('query' = 'worms_query')) %>%
  relocate(taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
arthropod_worms2 <- arthropod_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()


# extract higher and info about freshwater
arthropod_records <- search_records_worms(arthropod_worms2$worms_sciname)

# refine results to be useful
arthropod_records <- arthropod_records %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))


# now we'll search bold
arthropod_bold <- get_boldid_(sci = arthropod_search$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
arthropod_bold2 <- map_dfr(.x= arthropod_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
arthropod_gbifid <- get_gbifid_(sci = arthropod_search$taxa_query, rows = 1)

arthropod_gbifid2 <- map_dfr(.x= arthropod_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)





#4: merge all and find problems
# join all updated fields
arthropod2 <- arthropod_search %>%
  #select(species) %>%
  #rename(query = species) %>%
  left_join(arthropod_records) %>%
  left_join(arthropod_bold2) %>%
  left_join(arthropod_gbifid2) %>%
  left_join(arthropod_tol2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank'), .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_query, worms_match, original_aphiaid, taxa)))


#write full
write.csv(arthropod2, here(rosetta, 'taxize', '20220718_arthropod_taxonomy-full.csv'))

# not-found list
arthropod_notfound <- arthropod %>%
  #filter(phylum == 'arthropoda') %>%
  #select(species, phylum, class, family) %>%
  #distinct() %>%
  #filter(!(is.na(species) | species == "")) %>%
  #not in gbif or obis or worms
  filter(!(taxa %in% arthropod_gbifid2$taxa_query |
           taxa %in% arthropod_bold2$taxa_query | 
           taxa %in% arthropod_records$taxa_query |
           taxa %in% arthropod_tol2$taxa))

#write out not-found
write.csv(arthropod_notfound, here(rosetta, 'problems', '20220718_arthropod_not-found.csv'))

# for instances where the TOL resolve wasn't actually worms-ok
arthropod_nf_worms <- arthropod2 %>%
  filter(is.na(worms_aphiaid) == TRUE & is.na(ott_id) == FALSE)

#write out worms issues
write.csv(arthropod_nf_worms, here(rosetta, 'problems', '20220718_arthropod_worms-tol-conflict.csv'))
```



### Chordates

```{r}
# in chordates there are some duplicates in class + family
chordata <- chordata %>%
  select(!(c(class, family))) %>%
  distinct()

# 1: tol_resolve
# first get resolved names from tol
chordata_resolved <- tol_resolve(chordata$taxa, context_name = 'Animals') %>%
  mutate(search_string = str_to_sentence(search_string))

# format for merge
chordata_tol2 <- chordata_resolved %>%
  select(!(c(approximate_match, number_matches))) %>%
  # for not found list
  filter(!(is.na(unique_name))) %>%
  rename(taxa = search_string,
         tol_sciname = unique_name)

#then replace resolved
chordata_search <- chordata %>%
  left_join(chordata_resolved, by = c('taxa' = 'search_string')) %>%
  select(c(taxa, unique_name, phylum)) %>%
  #include replacements from tol and any overhanging taxa
  mutate(taxa_query = coalesce(unique_name, taxa)) %>%
  relocate(taxa_query) %>%
  #remove any known introduction from tol
  mutate(taxa_query = str_replace_all(taxa, ' \\(species in Opisthokonta\\)', "")) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", taxa_query)) %>%
  select(!(c(unique_name)))

# 2: worms
chordata_worms <- get_wormsid_(sci_com = chordata_search$worms_query, marine_only = FALSE, accepted = FALSE)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
chordata_worms2 <- chordata_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
chordata_worms2 <- chordata_worms2 %>%
  left_join(chordata_search, by = c('query' = 'worms_query')) %>%
  relocate(taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
chordata_worms2 <- chordata_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# extract higher and info about freshwater
chordata_records <- search_records_worms(chordata_worms2$worms_sciname)

# refine results to be useful
chordata_records <- chordata_records %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))


#3: gbif+bold ids
# now we'll search bold
chordata_bold <- get_boldid_(sci = chordata_search$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
chordata_bold2 <- map_dfr(.x= chordata_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
chordata_gbifid <- get_gbifid_(sci = chordata_search$taxa_query, rows = 1)

chordata_gbifid2 <- map_dfr(.x= chordata_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)

#4: merge all and find problems
# join all updated fields
chordata2 <- chordata_search %>%
  #select(species) %>%
  #rename(query = species) %>%
  left_join(chordata_records) %>%
  left_join(chordata_bold2) %>%
  left_join(chordata_gbifid2) %>%
  left_join(chordata_tol2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank'), .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_query, worms_match, original_aphiaid, taxa)))

#write full
write.csv(chordata2, here(rosetta, 'taxize', '20220718_chordata_taxonomy-full.csv'))

# not-found list
chordata_notfound <- chordata %>%
  #filter(phylum == 'chordataa') %>%
  #select(species, phylum, class, family) %>%
  #distinct() %>%
  #filter(!(is.na(species) | species == "")) %>%
  #not in gbif or obis or worms
  filter(!(taxa %in% chordata_gbifid2$taxa_query |
           taxa %in% chordata_bold2$taxa_query | 
           taxa %in% chordata_records$taxa_query |
           taxa %in% chordata_tol2$taxa))

#write out not-found
write.csv(chordata_notfound, here(rosetta, 'problems', '20220718_chordata_not-found.csv'))

# for instances where the TOL resolve wasn't actually worms-ok
chordata_nf_worms <- chordata2 %>%
  filter(is.na(worms_aphiaid) == TRUE & is.na(ott_id) == FALSE)

#write out worms issues
write.csv(chordata_nf_worms, here(rosetta, 'problems', '20220718_chordata_worms-tol-conflict.csv'))
```




### Molluscs


```{r}
# in chordates there are some duplicates in class + family
mollusca <- mollusca %>%
  select(!(c(class, family))) %>%
  distinct()

# 1: tol_resolve
# first get resolved names from tol
mollusca_resolved <- tol_resolve(mollusca$taxa, context_name = 'Animals') %>%
  mutate(search_string = str_to_sentence(search_string))

# format for merge
mollusca_tol2 <- mollusca_resolved %>%
  select(!(c(approximate_match, number_matches))) %>%
  # for not found list
  filter(!(is.na(unique_name))) %>%
  rename(taxa = search_string,
         tol_sciname = unique_name)


#then replace resolved
mollusca_search <- mollusca %>%
  left_join(mollusca_resolved, by = c('taxa' = 'search_string')) %>%
  select(c(taxa, unique_name, phylum)) %>%
  #include replacements from tol and any overhanging taxa
  mutate(taxa_query = coalesce(unique_name, taxa)) %>%
  relocate(taxa_query) %>%
  #remove any known introduction from tol
  mutate(taxa_query = str_replace_all(taxa, ' \\(species in Opisthokonta\\)', "")) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", taxa_query)) %>%
  select(!(c(unique_name)))

# 2: worms
mollusca_worms <- get_wormsid_(sci_com = mollusca_search$worms_query)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
mollusca_worms2 <- mollusca_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
mollusca_worms2 <- mollusca_worms2 %>%
  left_join(mollusca_search, by = c('query' = 'worms_query')) %>%
  relocate(taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
mollusca_worms2 <- mollusca_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()


# extract higher and info about freshwater
mollusca_records <- search_records_worms(mollusca_worms2$worms_sciname)

# refine results to be useful
mollusca_records <- mollusca_records %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))


#3: gbif+bold ids
# now we'll search bold
mollusca_bold <- get_boldid_(sci = mollusca_search$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
mollusca_bold2 <- map_dfr(.x= mollusca_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
mollusca_gbifid <- get_gbifid_(sci = mollusca_search$taxa_query, rows = 1)

mollusca_gbifid2 <- map_dfr(.x= mollusca_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)



#4: merge all and find problems
# join all updated fields
mollusca2 <- mollusca_search %>%
  #select(species) %>%
  #rename(query = species) %>%
  left_join(mollusca_records) %>%
  left_join(mollusca_bold2) %>%
  left_join(mollusca_gbifid2) %>%
  left_join(mollusca_tol2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank'), .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_query, worms_match, original_aphiaid, taxa)))


#write full
write.csv(mollusca2, here(rosetta, 'taxize', '20220718_mollusca_taxonomy-full.csv'))

# not-found list
mollusca_notfound <- mollusca %>%
  #filter(phylum == 'molluscaa') %>%
  #select(species, phylum, class, family) %>%
  #distinct() %>%
  #filter(!(is.na(species) | species == "")) %>%
  #not in gbif or obis or worms
  filter(!(taxa %in% mollusca_gbifid2$taxa_query |
           taxa %in% mollusca_bold2$taxa_query | 
           taxa %in% mollusca_records$taxa_query |
           taxa %in% mollusca_tol2$taxa))

#write out not-found
write.csv(mollusca_notfound, here(rosetta, 'problems', '20220718_mollusca_not-found.csv'))

# for instances where the TOL resolve wasn't actually worms-ok
mollusca_nf_worms <- mollusca2 %>%
  filter(is.na(worms_aphiaid) == TRUE & is.na(ott_id) == FALSE)

#write out worms issues
write.csv(mollusca_nf_worms, here(rosetta, 'problems', '20220718_mollusca_worms-tol-conflict.csv'))
```





### Echinoderms, Platyhelminthes, Nemerteans

These groups are done together since they are each moderate in size.


```{r}
# in chordates there are some duplicates in class + family
ech_platy_nem <- ech_platy_nem %>%
  select(!(c(class, family))) %>%
  distinct() %>%
  mutate(taxa = as.character(taxa))

# 1: tol_resolve
# first get resolved names from tol
ech_platy_nem_resolved <- tol_resolve(ech_platy_nem$taxa, context_name = 'Animals') %>%
  mutate(search_string = str_to_sentence(search_string))

# format for merge
ech_platy_nem_tol2 <- ech_platy_nem_resolved %>%
  select(!(c(approximate_match, number_matches))) %>%
  # for not found list
  filter(!(is.na(unique_name))) %>%
  rename(taxa = search_string,
         tol_sciname = unique_name)


#then replace resolved
ech_platy_nem_search <- ech_platy_nem %>%
  left_join(ech_platy_nem_resolved, by = c('taxa' = 'search_string')) %>%
  select(c(taxa, unique_name, phylum)) %>%
  #include replacements from tol and any overhanging taxa
  mutate(taxa_query = coalesce(unique_name, taxa)) %>%
  relocate(taxa_query) %>%
  #remove any known introduction from tol
  mutate(taxa_query = str_replace_all(taxa, ' \\(species in Opisthokonta\\)', "")) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", taxa_query)) %>%
  select(!(c(unique_name)))

# 2: worms
ech_platy_nem_worms <- get_wormsid_(sci_com = ech_platy_nem_search$worms_query)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
ech_platy_nem_worms2 <- ech_platy_nem_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
ech_platy_nem_worms2 <- ech_platy_nem_worms2 %>%
  left_join(ech_platy_nem_search, by = c('query' = 'worms_query')) %>%
  relocate(taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
ech_platy_nem_worms2 <- ech_platy_nem_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()


# extract higher and info about freshwater
ech_platy_nem_records <- search_records_worms(ech_platy_nem_worms2$worms_sciname)

# refine results to be useful
ech_platy_nem_records <- ech_platy_nem_records %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))


#3: gbif+bold ids
# now we'll search bold
ech_platy_nem_bold <- get_boldid_(sci = ech_platy_nem_search$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
ech_platy_nem_bold2 <- map_dfr(.x= ech_platy_nem_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
ech_platy_nem_gbifid <- get_gbifid_(sci = ech_platy_nem_search$taxa_query, rows = 1)

ech_platy_nem_gbifid2 <- map_dfr(.x= ech_platy_nem_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)



#4: merge all and find problems
# join all updated fields
ech_platy_nem2 <- ech_platy_nem_search %>%
  #select(species) %>%
  #rename(query = species) %>%
  left_join(ech_platy_nem_records) %>%
  left_join(ech_platy_nem_bold2) %>%
  left_join(ech_platy_nem_gbifid2) %>%
  left_join(ech_platy_nem_tol2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank'), .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_query, worms_match, original_aphiaid, taxa)))


#write full
write.csv(ech_platy_nem2, here(rosetta, 'taxize', '20220718_ech_platy_nem_taxonomy-full.csv'))

# not-found list
ech_platy_nem_notfound <- ech_platy_nem %>%
  #filter(phylum == 'ech_platy_nema') %>%
  #select(species, phylum, class, family) %>%
  #distinct() %>%
  #filter(!(is.na(species) | species == "")) %>%
  #not in gbif or obis or worms
  filter(!(taxa %in% ech_platy_nem_gbifid2$taxa_query |
           taxa %in% ech_platy_nem_bold2$taxa_query | 
           taxa %in% ech_platy_nem_records$taxa_query |
           taxa %in% ech_platy_nem_tol2$taxa))

#write out not-found
write.csv(ech_platy_nem_notfound, here(rosetta, 'problems', '20220718_ech_platy_nem_not-found.csv'))

# for instances where the TOL resolve wasn't actually worms-ok
ech_platy_nem_nf_worms <- ech_platy_nem2 %>%
  filter(is.na(worms_aphiaid) == TRUE & is.na(ott_id) == FALSE)

#write out worms issues
write.csv(ech_platy_nem_nf_worms, here(rosetta, 'problems', '20220718_ech_platy_nem_worms-tol-conflict.csv'))
```





### Small Phyla

Last but not least, everything else


```{r}
# in chordates there are some duplicates in class + family
small_phyla <- small_phyla %>%
  select(!(c(class, family))) %>%
  distinct() %>%
  mutate(taxa = as.character(taxa))

# 1: tol_resolve
# first get resolved names from tol
small_phyla_resolved <- tol_resolve(small_phyla$taxa, context_name = 'Animals') %>%
  mutate(search_string = str_to_sentence(search_string))

# format for merge
small_phyla_tol2 <- small_phyla_resolved %>%
  select(!(c(approximate_match, number_matches))) %>%
  # for not found list
  filter(!(is.na(unique_name))) %>%
  rename(taxa = search_string,
         tol_sciname = unique_name)


#then replace resolved
small_phyla_search <- small_phyla %>%
  left_join(small_phyla_resolved, by = c('taxa' = 'search_string')) %>%
  select(c(taxa, unique_name, phylum)) %>%
  #include replacements from tol and any overhanging taxa
  mutate(taxa_query = coalesce(unique_name, taxa)) %>%
  relocate(taxa_query) %>%
  #remove any known introduction from tol
  mutate(taxa_query = str_replace_all(taxa, ' \\(species in Opisthokonta\\)', "")) %>%
  ## temporary issue requires replacing whitespace with '+'
  mutate(worms_query = gsub(" ", "+", taxa_query)) %>%
  select(!(c(unique_name)))

# 2: worms
small_phyla_worms <- get_wormsid_(sci_com = small_phyla_search$worms_query)
# get_wormsid_ gives back null and length 0 elements
## first remove with compact and discard then map_dfr
small_phyla_worms2 <- small_phyla_worms %>% 
  compact() %>%
  discard( ~ nrow(.x) == 0) %>%
  map_dfr( ~ data.frame(.x), .id = 'query')

# this cleaning step is relatively temporary until they fix the curl issue
small_phyla_worms2 <- small_phyla_worms2 %>%
  left_join(small_phyla_search, by = c('query' = 'worms_query')) %>%
  relocate(taxa) %>%
  select(!(query))

# now match species to sciname to remove extra rows
small_phyla_worms2 <- small_phyla_worms2 %>%
  # remove higher taxonomy with species-level hits
  filter(!(str_detect(taxa, " ") == FALSE & str_detect(scientificname, " ") == TRUE)) %>%
  filter(!(!(taxa == scientificname))) %>%
  select(!(c(status))) %>%
  rename(worms_aphiaid = AphiaID,
        worms_sciname = scientificname) %>%
  distinct()

# extract higher and info about freshwater
small_phyla_records <- search_records_worms(small_phyla_worms2$worms_sciname)
0
# refine results to be useful
small_phyla_records <- small_phyla_records %>%
  # only animal hits
  filter(kingdom == 'Animalia') %>%
  # generate terrestrial-only and freshwater-only columns
  mutate(freshwater_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_freshwater == 1),  "1", "0")) %>%
    mutate(terrestrial_only = ifelse((is_marine %in% c(0, NA) ==TRUE) & (is_brackish %in% c(0,NA) == TRUE) & (is_terrestrial == 1),  "1", "0")) %>%
  distinct() %>%
  # rename to format
  rename(taxa_query = query,
         worms_aphiaid = valid_aphia_id,
         original_aphiaid =aphia_id,
         worms_match = scientificname,
         worms_sciname = valid_name
         ) %>%
  # remove unneeded columns
  select(!(c(authority, parent_name_usage_id, is_freshwater, 
             is_terrestrial, is_marine, is_brackish, is_extinct, match_type))) %>%
  relocate(c(worms_sciname, worms_aphiaid), .before = original_aphiaid) %>%
  # rank lowercase
  mutate(rank = tolower(rank))



#3: gbif+bold ids
# now we'll search bold
small_phyla_bold <- get_boldid_(sci = small_phyla_search$taxa_query, 
                         includeTree = TRUE,
                         divison = 'Animalia')
#bind up lists into a dataframe
small_phyla_bold2 <- map_dfr(.x= small_phyla_bold, ~ data.frame(.x)) %>%
  filter(!(is.na(input))) %>%
  filter(!(is.na(taxid))) %>%
  filter(tax_division == 'Animalia') %>%
  # remove cases where input is higher taxonomy and taxon is species epthet
  filter(!(str_detect(input, " ") == FALSE & str_detect(taxon, " ") == TRUE)) %>%
  select(!(c(representitive_image.image, 
             representitive_image.apectratio))) %>%
  remove_rownames() %>%
  relocate(input) %>%
  distinct() %>%
  # prep to merge with other searches
  rename(bold_id = taxid,
         taxa_query = input,
         rank = tax_rank,
         bold_taxon = taxon) %>%
  select((c(taxa_query, bold_id, bold_taxon, rank)))

# GBIF id
small_phyla_gbifid <- get_gbifid_(sci = small_phyla_search$taxa_query, rows = 1)

small_phyla_gbifid2 <- map_dfr(.x= small_phyla_gbifid, ~ data.frame(.x), .id = 'taxa_query') %>%
  filter(kingdom == "Animalia") %>%
  # eliminating fuzzy matches for now
  filter(matchtype == 'EXACT') %>%
  # strip higher taxonomy from gbif bc it doesn't match worms/bold
  ## but keep keys!
  select(!(c(kingdom, phylum, class, order, family, genus, species,
             status, confidence, canonicalname, matchtype, kingdomkey,
             # just keeping regular gbif key
             acceptedusagekey, phylumkey, orderkey,
             classkey, familykey, genuskey, specieskey,
             synonym, note))) %>%
    rename(gbif_key = usagekey,
         gbif_sciname = scientificname)



#4: merge all and find problems
#4: merge all and find problems
# join all updated fields
small_phyla2 <- small_phyla_search %>%
  #select(species) %>%
  #rename(query = species) %>%
  left_join(small_phyla_records) %>%
  left_join(small_phyla_bold2) %>%
  left_join(small_phyla_gbifid2) %>%
  left_join(small_phyla_tol2) %>%
  relocate(c('worms_aphiaid', 'bold_id', 'gbif_key', 'ott_id'), .before = 'phylum') %>%
  relocate(c('worms_sciname', 'tol_sciname', 'bold_taxon', 'gbif_sciname'), .before = 'phylum') %>%
  #single column for TOL and WORMS replacements; bold and gbif tend to follow TOL
  mutate(found_taxa = coalesce(worms_sciname, tol_sciname)) %>%
  relocate(c('found_taxa', 'rank'), .before = 'worms_aphiaid') %>%
  relocate('family', .before = 'genus') %>%
  relocate(c('is_synonym', 'flags'), .before = 'valid_authority') %>%
  select(!(c(worms_query, worms_match, original_aphiaid, taxa)))


#write full
write.csv(small_phyla2, here(rosetta, 'taxize', '20220718_small_phyla_taxonomy-full.csv'))

# not-found list
small_phyla_notfound <- small_phyla %>%
  #filter(phylum == 'small_phylaa') %>%
  #select(species, phylum, class, family) %>%
  #distinct() %>%
  #filter(!(is.na(species) | species == "")) %>%
  #not in gbif or obis or worms
  filter(!(taxa %in% small_phyla_gbifid2$taxa_query |
           taxa %in% small_phyla_bold2$taxa_query | 
           taxa %in% small_phyla_records$taxa_query |
           taxa %in% small_phyla_tol2$taxa))

#write out not-found
write.csv(small_phyla_notfound, here(rosetta, 'problems', '20220718_small_phyla_not-found.csv'))

# for instances where the TOL resolve wasn't actually worms-ok
small_phyla_nf_worms <- small_phyla2 %>%
  filter(is.na(worms_aphiaid) == TRUE & is.na(ott_id) == FALSE)

#write out worms issues
write.csv(small_phyla_nf_worms, here(rosetta, 'problems', '20220718_small_phyla_worms-tol-conflict.csv'))
```



This might be for a later script now, after problems are fixed
## Merge generated files

```{r}
# merge files
#this method seems slow so maybe turn into a dplyr join or whatever
rosetta <- merge(merge(merge(merge(merge(annelid, 
                                   arthropod, all = TRUE), 
                 chordata, all = TRUE),
                 mollusc, all = TRUE),
                 ech_platy_nem, all = TRUE),
                 small_phyla, all = TRUE)

# rename columns
#note that as of right now species column is the full epithet rather than 
# just the specific epithet as darwincore would like. 
# at a later date I will add a line to make the specific epithet then 
#turn "species" this into an ID column or something
rosetta <- rosetta %>%
  select(BIN, Process.ID, Catalog.Num, ott_id,
         Domain, Kingdom, Phylum, Class, Order, Family, Genus, Species, 
         verbatimTaxonRank, previousIdentifications, is_synonym) %>%
  rename(associatedSequences = BIN,
         recordNumber = Process.ID,
         catalogNumber = Catalog.Num,
         domain = Domain,
         kingdom = Kingdom,
         phylum = Phylum,
         class = Class,
         order = Order,
         family = Family,
         genus = Genus,
         species = Species) %>%
  na_if(., "")

# save
write_csv(rosetta, here('hakaidata', '2021rosetta', 'taxize', 
                              '20210812_rosetta.csv'))
```

maybe write a python script for if you only updated one file